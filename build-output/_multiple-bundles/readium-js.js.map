{
  "version": 3,
  "file": "readium-js.js",
  "sources": [
    "text.js",
    "../version.json!text",
    "../../js/epub-fetch/markup_parser.js",
    "../../js/epub-fetch/discover_content_type.js",
    "../../js/epub-fetch/plain_resource_fetcher.js",
    "zip.js",
    "zip-fs.js",
    "zip-ext.js",
    "../../js/epub-fetch/zip_resource_fetcher.js",
    "../../js/epub-fetch/content_document_fetcher.js",
    "../../js/epub-fetch/resource_cache.js",
    "../../node_modules/crypto-js/core.js",
    "../../node_modules/crypto-js/sha1.js",
    "../../js/epub-fetch/encryption_handler.js",
    "../../js/epub-fetch/publication_fetcher.js",
    "../../js/epub-model/package_document.js",
    "../../js/epub-model/smil_document_parser.js",
    "../../js/epub-model/metadata.js",
    "../../js/epub-model/manifest.js",
    "../../js/epub-model/package_document_parser.js",
    "../../js/epub-fetch/iframe_zip_loader.js",
    "Readium.js",
    "readium-js.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtYA,ADuYA;ACtYA;AACA;ACFA,ADGA;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjCA,ADkCA;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACj8BA,ADk8BA;ACj8BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpiBA,ADqiBA;ACpiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzPA,AD0PA;ACzPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3GA,AD4GA;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1LA;AACA;AACA;AACA,ACHA;ACAA,ADCA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxPA,ADyPA;ACxPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5DA,AD6DA;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzeA,AD0eA;ACzeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "/**\n * @license RequireJS text 2.0.12 Copyright (c) 2010-2014, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/requirejs/text for details\n */\n/*jslint regexp: true */\n/*global require, XMLHttpRequest, ActiveXObject,\n  define, window, process, Packages,\n  java, location, Components, FileUtils */\n\ndefine('text',['module'], function (module) {\n    'use strict';\n\n    var text, fs, Cc, Ci, xpcIsWindows,\n        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],\n        xmlRegExp = /^\\s*<\\?xml(\\s)+version=[\\'\\\"](\\d)*.(\\d)*[\\'\\\"](\\s)*\\?>/im,\n        bodyRegExp = /<body[^>]*>\\s*([\\s\\S]+)\\s*<\\/body>/im,\n        hasLocation = typeof location !== 'undefined' && location.href,\n        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\\:/, ''),\n        defaultHostName = hasLocation && location.hostname,\n        defaultPort = hasLocation && (location.port || undefined),\n        buildMap = {},\n        masterConfig = (module.config && module.config()) || {};\n\n    text = {\n        version: '2.0.12',\n\n        strip: function (content) {\n            //Strips <?xml ...?> declarations so that external SVG and XML\n            //documents can be added to a document without worry. Also, if the string\n            //is an HTML document, only the part inside the body tag is returned.\n            if (content) {\n                content = content.replace(xmlRegExp, \"\");\n                var matches = content.match(bodyRegExp);\n                if (matches) {\n                    content = matches[1];\n                }\n            } else {\n                content = \"\";\n            }\n            return content;\n        },\n\n        jsEscape: function (content) {\n            return content.replace(/(['\\\\])/g, '\\\\$1')\n                .replace(/[\\f]/g, \"\\\\f\")\n                .replace(/[\\b]/g, \"\\\\b\")\n                .replace(/[\\n]/g, \"\\\\n\")\n                .replace(/[\\t]/g, \"\\\\t\")\n                .replace(/[\\r]/g, \"\\\\r\")\n                .replace(/[\\u2028]/g, \"\\\\u2028\")\n                .replace(/[\\u2029]/g, \"\\\\u2029\");\n        },\n\n        createXhr: masterConfig.createXhr || function () {\n            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.\n            var xhr, i, progId;\n            if (typeof XMLHttpRequest !== \"undefined\") {\n                return new XMLHttpRequest();\n            } else if (typeof ActiveXObject !== \"undefined\") {\n                for (i = 0; i < 3; i += 1) {\n                    progId = progIds[i];\n                    try {\n                        xhr = new ActiveXObject(progId);\n                    } catch (e) {}\n\n                    if (xhr) {\n                        progIds = [progId];  // so faster next time\n                        break;\n                    }\n                }\n            }\n\n            return xhr;\n        },\n\n        /**\n         * Parses a resource name into its component parts. Resource names\n         * look like: module/name.ext!strip, where the !strip part is\n         * optional.\n         * @param {String} name the resource name\n         * @returns {Object} with properties \"moduleName\", \"ext\" and \"strip\"\n         * where strip is a boolean.\n         */\n        parseName: function (name) {\n            var modName, ext, temp,\n                strip = false,\n                index = name.indexOf(\".\"),\n                isRelative = name.indexOf('./') === 0 ||\n                             name.indexOf('../') === 0;\n\n            if (index !== -1 && (!isRelative || index > 1)) {\n                modName = name.substring(0, index);\n                ext = name.substring(index + 1, name.length);\n            } else {\n                modName = name;\n            }\n\n            temp = ext || modName;\n            index = temp.indexOf(\"!\");\n            if (index !== -1) {\n                //Pull off the strip arg.\n                strip = temp.substring(index + 1) === \"strip\";\n                temp = temp.substring(0, index);\n                if (ext) {\n                    ext = temp;\n                } else {\n                    modName = temp;\n                }\n            }\n\n            return {\n                moduleName: modName,\n                ext: ext,\n                strip: strip\n            };\n        },\n\n        xdRegExp: /^((\\w+)\\:)?\\/\\/([^\\/\\\\]+)/,\n\n        /**\n         * Is an URL on another domain. Only works for browser use, returns\n         * false in non-browser environments. Only used to know if an\n         * optimized .js version of a text resource should be loaded\n         * instead.\n         * @param {String} url\n         * @returns Boolean\n         */\n        useXhr: function (url, protocol, hostname, port) {\n            var uProtocol, uHostName, uPort,\n                match = text.xdRegExp.exec(url);\n            if (!match) {\n                return true;\n            }\n            uProtocol = match[2];\n            uHostName = match[3];\n\n            uHostName = uHostName.split(':');\n            uPort = uHostName[1];\n            uHostName = uHostName[0];\n\n            return (!uProtocol || uProtocol === protocol) &&\n                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&\n                   ((!uPort && !uHostName) || uPort === port);\n        },\n\n        finishLoad: function (name, strip, content, onLoad) {\n            content = strip ? text.strip(content) : content;\n            if (masterConfig.isBuild) {\n                buildMap[name] = content;\n            }\n            onLoad(content);\n        },\n\n        load: function (name, req, onLoad, config) {\n            //Name has format: some.module.filext!strip\n            //The strip part is optional.\n            //if strip is present, then that means only get the string contents\n            //inside a body tag in an HTML string. For XML/SVG content it means\n            //removing the <?xml ...?> declarations so the content can be inserted\n            //into the current doc without problems.\n\n            // Do not bother with the work if a build and text will\n            // not be inlined.\n            if (config && config.isBuild && !config.inlineText) {\n                onLoad();\n                return;\n            }\n\n            masterConfig.isBuild = config && config.isBuild;\n\n            var parsed = text.parseName(name),\n                nonStripName = parsed.moduleName +\n                    (parsed.ext ? '.' + parsed.ext : ''),\n                url = req.toUrl(nonStripName),\n                useXhr = (masterConfig.useXhr) ||\n                         text.useXhr;\n\n            // Do not load if it is an empty: url\n            if (url.indexOf('empty:') === 0) {\n                onLoad();\n                return;\n            }\n\n            //Load the text. Use XHR if possible and in a browser.\n            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {\n                text.get(url, function (content) {\n                    text.finishLoad(name, parsed.strip, content, onLoad);\n                }, function (err) {\n                    if (onLoad.error) {\n                        onLoad.error(err);\n                    }\n                });\n            } else {\n                //Need to fetch the resource across domains. Assume\n                //the resource has been optimized into a JS module. Fetch\n                //by the module name + extension, but do not include the\n                //!strip part to avoid file system issues.\n                req([nonStripName], function (content) {\n                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,\n                                    parsed.strip, content, onLoad);\n                });\n            }\n        },\n\n        write: function (pluginName, moduleName, write, config) {\n            if (buildMap.hasOwnProperty(moduleName)) {\n                var content = text.jsEscape(buildMap[moduleName]);\n                write.asModule(pluginName + \"!\" + moduleName,\n                               \"define(function () { return '\" +\n                                   content +\n                               \"';});\\n\");\n            }\n        },\n\n        writeFile: function (pluginName, moduleName, req, write, config) {\n            var parsed = text.parseName(moduleName),\n                extPart = parsed.ext ? '.' + parsed.ext : '',\n                nonStripName = parsed.moduleName + extPart,\n                //Use a '.js' file name so that it indicates it is a\n                //script that can be loaded across domains.\n                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';\n\n            //Leverage own load() method to load plugin value, but only\n            //write out values that do not have the strip argument,\n            //to avoid any potential issues with ! in file names.\n            text.load(nonStripName, req, function (value) {\n                //Use own write() method to construct full module value.\n                //But need to create shell that translates writeFile's\n                //write() to the right interface.\n                var textWrite = function (contents) {\n                    return write(fileName, contents);\n                };\n                textWrite.asModule = function (moduleName, contents) {\n                    return write.asModule(moduleName, fileName, contents);\n                };\n\n                text.write(pluginName, nonStripName, textWrite, config);\n            }, config);\n        }\n    };\n\n    if (masterConfig.env === 'node' || (!masterConfig.env &&\n            typeof process !== \"undefined\" &&\n            process.versions &&\n            !!process.versions.node &&\n            !process.versions['node-webkit'])) {\n        //Using special require.nodeRequire, something added by r.js.\n        fs = require.nodeRequire('fs');\n\n        text.get = function (url, callback, errback) {\n            try {\n                var file = fs.readFileSync(url, 'utf8');\n                //Remove BOM (Byte Mark Order) from utf8 files if it is there.\n                if (file.indexOf('\\uFEFF') === 0) {\n                    file = file.substring(1);\n                }\n                callback(file);\n            } catch (e) {\n                if (errback) {\n                    errback(e);\n                }\n            }\n        };\n    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&\n            text.createXhr())) {\n        text.get = function (url, callback, errback, headers) {\n            var xhr = text.createXhr(), header;\n            xhr.open('GET', url, true);\n\n            //Allow plugins direct access to xhr headers\n            if (headers) {\n                for (header in headers) {\n                    if (headers.hasOwnProperty(header)) {\n                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);\n                    }\n                }\n            }\n\n            //Allow overrides specified in config\n            if (masterConfig.onXhr) {\n                masterConfig.onXhr(xhr, url);\n            }\n\n            xhr.onreadystatechange = function (evt) {\n                var status, err;\n                //Do not explicitly handle errors, those should be\n                //visible via console output in the browser.\n                if (xhr.readyState === 4) {\n                    status = xhr.status || 0;\n                    if (status > 399 && status < 600) {\n                        //An http 4xx or 5xx error. Signal an error.\n                        err = new Error(url + ' HTTP status: ' + status);\n                        err.xhr = xhr;\n                        if (errback) {\n                            errback(err);\n                        }\n                    } else {\n                        callback(xhr.responseText);\n                    }\n\n                    if (masterConfig.onXhrComplete) {\n                        masterConfig.onXhrComplete(xhr, url);\n                    }\n                }\n            };\n            xhr.send(null);\n        };\n    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&\n            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {\n        //Why Java, why is this so awkward?\n        text.get = function (url, callback) {\n            var stringBuffer, line,\n                encoding = \"utf-8\",\n                file = new java.io.File(url),\n                lineSeparator = java.lang.System.getProperty(\"line.separator\"),\n                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),\n                content = '';\n            try {\n                stringBuffer = new java.lang.StringBuffer();\n                line = input.readLine();\n\n                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324\n                // http://www.unicode.org/faq/utf_bom.html\n\n                // Note that when we use utf-8, the BOM should appear as \"EF BB BF\", but it doesn't due to this bug in the JDK:\n                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058\n                if (line && line.length() && line.charAt(0) === 0xfeff) {\n                    // Eat the BOM, since we've already found the encoding on this file,\n                    // and we plan to concatenating this buffer with others; the BOM should\n                    // only appear at the top of a file.\n                    line = line.substring(1);\n                }\n\n                if (line !== null) {\n                    stringBuffer.append(line);\n                }\n\n                while ((line = input.readLine()) !== null) {\n                    stringBuffer.append(lineSeparator);\n                    stringBuffer.append(line);\n                }\n                //Make sure we return a JavaScript string and not a Java string.\n                content = String(stringBuffer.toString()); //String\n            } finally {\n                input.close();\n            }\n            callback(content);\n        };\n    } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&\n            typeof Components !== 'undefined' && Components.classes &&\n            Components.interfaces)) {\n        //Avert your gaze!\n        Cc = Components.classes;\n        Ci = Components.interfaces;\n        Components.utils['import']('resource://gre/modules/FileUtils.jsm');\n        xpcIsWindows = ('@mozilla.org/windows-registry-key;1' in Cc);\n\n        text.get = function (url, callback) {\n            var inStream, convertStream, fileObj,\n                readData = {};\n\n            if (xpcIsWindows) {\n                url = url.replace(/\\//g, '\\\\');\n            }\n\n            fileObj = new FileUtils.File(url);\n\n            //XPCOM, you so crazy\n            try {\n                inStream = Cc['@mozilla.org/network/file-input-stream;1']\n                           .createInstance(Ci.nsIFileInputStream);\n                inStream.init(fileObj, 1, 0, false);\n\n                convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']\n                                .createInstance(Ci.nsIConverterInputStream);\n                convertStream.init(inStream, \"utf-8\", inStream.available(),\n                Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);\n\n                convertStream.readString(inStream.available(), readData);\n                convertStream.close();\n                inStream.close();\n                callback(readData.value);\n            } catch (e) {\n                throw new Error((fileObj && fileObj.path || '') + ': ' + e);\n            }\n        };\n    }\n    return text;\n});\n\n",
    "\ndefine('text!../version.json',[],function () { return '{\"readiumJs\":{\"sha\":\"e1ad17674b734b43258ec29ee3329abdb443a056\",\"tag\":\"0.15-101-ge1ad176\",\"clean\":false},\"readiumSharedJs\":{\"sha\":\"4f5d7425d4756dde11b9ec816165ffc4245eb7cb\",\"tag\":\"0.16-97-g4f5d742\",\"clean\":true}}';});\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\ndefine('epub-fetch/markup_parser',[],\r\n    function () {\r\n\r\n        var MarkupParser = function (){\r\n\r\n            var self = this;\r\n\r\n            this.parseXml = function(xmlString) {\r\n                return self.parseMarkup(xmlString, 'text/xml');\r\n            };\r\n\r\n            this.parseMarkup = function(markupString, contentType) {\r\n                var parser = new window.DOMParser;\r\n                return parser.parseFromString(markupString, contentType);\r\n            };\r\n\r\n        };\r\n\r\n        return MarkupParser;\r\n});\r\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\ndefine('epub-fetch/discover_content_type',['jquery', 'URIjs'], function ($, URI) {\r\n\r\n    var _instance = undefined;\r\n\r\n    var ContentTypeDiscovery = function() {\r\n\r\n        var self = this;\r\n\r\n        ContentTypeDiscovery.suffixContentTypeMap = {\r\n            css: 'text/css',\r\n            epub: 'application/epub+zip',\r\n            gif: 'image/gif',\r\n            html: 'text/html',\r\n            jpg: 'image/jpeg',\r\n            jpeg: 'image/jpeg',\r\n            ncx: 'application/x-dtbncx+xml',\r\n            opf: 'application/oebps-package+xml',\r\n            png: 'image/png',\r\n            svg: 'image/svg+xml',\r\n            xhtml: 'application/xhtml+xml'\r\n        };\r\n\r\n        this.identifyContentTypeFromFileName = function(contentUrl) {\r\n            var contentUrlSuffix = URI(contentUrl).suffix();\r\n            var contentType = 'application/octet-stream';\r\n            if (typeof ContentTypeDiscovery.suffixContentTypeMap[contentUrlSuffix] !== 'undefined') {\r\n                contentType = ContentTypeDiscovery.suffixContentTypeMap[contentUrlSuffix];\r\n            }\r\n            return contentType;\r\n        };\r\n\r\n        this.identifyContentType = function (contentUrl) {\r\n            // TODO: Make the call asynchronous (which would require a callback and would probably make sense\r\n            // when calling functions are also remodelled for async).\r\n\r\n            var contentType = $.ajax({\r\n                type: \"HEAD\",\r\n                url: contentUrl,\r\n                async: false\r\n            }).getResponseHeader('Content-Type');\r\n            if (contentType === null) {\r\n                contentType = self.identifyContentTypeFromFileName(contentUrl);\r\n                console.log('guessed contentType [' + contentType + '] from URI [' + contentUrl +\r\n                    ']. Configuring the web server to provide the content type is recommended.');\r\n\r\n            }\r\n\r\n            return contentType;\r\n        }\r\n\r\n    };\r\n\r\n    if(!_instance) {\r\n        _instance = new ContentTypeDiscovery();\r\n    }\r\n\r\n    return _instance;\r\n\r\n});\r\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\ndefine('epub-fetch/plain_resource_fetcher',['jquery', 'URIjs', './discover_content_type'], function ($, URI, ContentTypeDiscovery) {\r\n\r\n    var PlainResourceFetcher = function(parentFetcher, baseUrl){\r\n\r\n        var self = this;\r\n        var _packageDocumentAbsoluteUrl;\r\n        var _packageDocumentRelativePath;\r\n\r\n        // INTERNAL FUNCTIONS\r\n\r\n        function fetchFileContents(pathRelativeToPackageRoot, readCallback, onerror) {\r\n            var fileUrl = self.resolveURI(pathRelativeToPackageRoot);\r\n\r\n            if (typeof pathRelativeToPackageRoot === 'undefined') {\r\n                throw 'Fetched file relative path is undefined!';\r\n            }\r\n\r\n            var xhr = new XMLHttpRequest();\r\n            xhr.open('GET', fileUrl, true);\r\n            xhr.responseType = 'arraybuffer';\r\n            xhr.onerror = onerror;\r\n\r\n            xhr.onload = function (loadEvent) {\r\n                readCallback(xhr.response);\r\n            };\r\n\r\n            xhr.send();\r\n        }\r\n\r\n\r\n        // PUBLIC API\r\n\r\n        this.initialize = function(callback) {\r\n\r\n            parentFetcher.getXmlFileDom('META-INF/container.xml', function (containerXmlDom) {\r\n                _packageDocumentRelativePath = parentFetcher.getRootFile(containerXmlDom);\r\n                _packageDocumentAbsoluteUrl = self.resolveURI(_packageDocumentRelativePath);\r\n\r\n                callback();\r\n\r\n            }, function(error) {\r\n                console.error(\"unable to find package document: \" + error);\r\n                _packageDocumentAbsoluteUrl = baseUrl;\r\n\r\n                callback();\r\n            });\r\n        };\r\n\r\n        this.resolveURI = function (pathRelativeToPackageRoot) {\r\n            return baseUrl + \"/\" + pathRelativeToPackageRoot;\r\n        };\r\n\r\n\r\n        this.getPackageUrl = function() {\r\n            return _packageDocumentAbsoluteUrl;\r\n        };\r\n\r\n        this.fetchFileContentsText = function(pathRelativeToPackageRoot, fetchCallback, onerror) {\r\n            var fileUrl = self.resolveURI(pathRelativeToPackageRoot);\r\n\r\n            if (typeof fileUrl === 'undefined') {\r\n                throw 'Fetched file URL is undefined!';\r\n            }\r\n            $.ajax({\r\n                // encoding: \"UTF-8\",\r\n                // mimeType: \"text/plain; charset=UTF-8\",\r\n                // beforeSend: function( xhr ) {\r\n                //     xhr.overrideMimeType(\"text/plain; charset=UTF-8\");\r\n                // },\r\n                isLocal: fileUrl.indexOf(\"http\") === 0 ? false : true,\r\n                url: fileUrl,\r\n                dataType: 'text', //https://api.jquery.com/jQuery.ajax/\r\n                async: true,\r\n                success: function (result) {\r\n                    fetchCallback(result);\r\n                },\r\n                error: function (xhr, status, errorThrown) {\r\n                    console.error('Error when AJAX fetching ' + fileUrl);\r\n                    console.error(status);\r\n                    console.error(errorThrown);\r\n\r\n                    // // isLocal = false with custom URI scheme / protocol results in false fail on Firefox (Chrome okay)\r\n                    // if (status === \"error\" && (!errorThrown || !errorThrown.length) && xhr.responseText && xhr.responseText.length)\r\n                    // {\r\n                    //     console.error(xhr);\r\n                    //     if (typeof xhr.getResponseHeader !== \"undefined\") console.error(xhr.getResponseHeader(\"Content-Type\"));\r\n                    //     if (typeof xhr.getAllResponseHeaders !== \"undefined\") console.error(xhr.getAllResponseHeaders());\r\n                    //     if (typeof xhr.responseText !== \"undefined\") console.error(xhr.responseText);\r\n                    //     \r\n                    //     // success\r\n                    //     fetchCallback(xhr.responseText);\r\n                    //     return;\r\n                    // }\r\n                    \r\n                    onerror(errorThrown);\r\n                }\r\n            });\r\n        };\r\n\r\n        this.fetchFileContentsBlob = function(pathRelativeToPackageRoot, fetchCallback, onerror) {\r\n\r\n            var decryptionFunction = parentFetcher.getDecryptionFunctionForRelativePath(pathRelativeToPackageRoot);\r\n            if (decryptionFunction) {\r\n                var origFetchCallback = fetchCallback;\r\n                fetchCallback = function (unencryptedBlob) {\r\n                    decryptionFunction(unencryptedBlob, function (decryptedBlob) {\r\n                        origFetchCallback(decryptedBlob);\r\n                    });\r\n                };\r\n            }\r\n            fetchFileContents(pathRelativeToPackageRoot, function (contentsArrayBuffer) {\r\n                var blob = new Blob([contentsArrayBuffer], {\r\n                    type: ContentTypeDiscovery.identifyContentTypeFromFileName(pathRelativeToPackageRoot)\r\n                });\r\n                fetchCallback(blob);\r\n            }, onerror);\r\n        };\r\n\r\n        this.getPackageDom = function (callback, onerror) {\r\n            self.fetchFileContentsText(_packageDocumentRelativePath, function (packageXml) {\r\n                var packageDom = parentFetcher.markupParser.parseXml(packageXml);\r\n                callback(packageDom);\r\n            }, onerror);\r\n        };\r\n\r\n    };\r\n\r\n    return PlainResourceFetcher;\r\n});\r\n\n",
    "/*\r\n Copyright (c) 2013 Gildas Lormeau. All rights reserved.\r\n\r\n Redistribution and use in source and binary forms, with or without\r\n modification, are permitted provided that the following conditions are met:\r\n\r\n 1. Redistributions of source code must retain the above copyright notice,\r\n this list of conditions and the following disclaimer.\r\n\r\n 2. Redistributions in binary form must reproduce the above copyright\r\n notice, this list of conditions and the following disclaimer in\r\n the documentation and/or other materials provided with the distribution.\r\n\r\n 3. The names of the authors may not be used to endorse or promote products\r\n derived from this software without specific prior written permission.\r\n\r\n THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\r\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\r\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\r\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\r\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\r\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\r\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\r\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\r\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n(function(obj) {\r\n\t\"use strict\";\r\n\r\n\tvar ERR_BAD_FORMAT = \"File format is not recognized.\";\r\n\tvar ERR_CRC = \"CRC failed.\";\r\n\tvar ERR_ENCRYPTED = \"File contains encrypted entry.\";\r\n\tvar ERR_ZIP64 = \"File is using Zip64 (4gb+ file size).\";\r\n\tvar ERR_READ = \"Error while reading zip file.\";\r\n\tvar ERR_WRITE = \"Error while writing zip file.\";\r\n\tvar ERR_WRITE_DATA = \"Error while writing file data.\";\r\n\tvar ERR_READ_DATA = \"Error while reading file data.\";\r\n\tvar ERR_DUPLICATED_NAME = \"File already exists.\";\r\n\tvar CHUNK_SIZE = 512 * 1024;\r\n\t\r\n\tvar TEXT_PLAIN = \"text/plain\";\r\n\r\n\tvar appendABViewSupported;\r\n\ttry {\r\n\t\tappendABViewSupported = new Blob([ new DataView(new ArrayBuffer(0)) ]).size === 0;\r\n\t} catch (e) {\r\n\t}\r\n\r\n\tfunction Crc32() {\r\n\t\tthis.crc = -1;\r\n\t}\r\n\tCrc32.prototype.append = function append(data) {\r\n\t\tvar crc = this.crc | 0, table = this.table;\r\n\t\tfor (var offset = 0, len = data.length | 0; offset < len; offset++)\r\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ data[offset]) & 0xFF];\r\n\t\tthis.crc = crc;\r\n\t};\r\n\tCrc32.prototype.get = function get() {\r\n\t\treturn ~this.crc;\r\n\t};\r\n\tCrc32.prototype.table = (function() {\r\n\t\tvar i, j, t, table = []; // Uint32Array is actually slower than []\r\n\t\tfor (i = 0; i < 256; i++) {\r\n\t\t\tt = i;\r\n\t\t\tfor (j = 0; j < 8; j++)\r\n\t\t\t\tif (t & 1)\r\n\t\t\t\t\tt = (t >>> 1) ^ 0xEDB88320;\r\n\t\t\t\telse\r\n\t\t\t\t\tt = t >>> 1;\r\n\t\t\ttable[i] = t;\r\n\t\t}\r\n\t\treturn table;\r\n\t})();\r\n\t\r\n\t// \"no-op\" codec\r\n\tfunction NOOP() {}\r\n\tNOOP.prototype.append = function append(bytes, onprogress) {\r\n\t\treturn bytes;\r\n\t};\r\n\tNOOP.prototype.flush = function flush() {};\r\n\r\n\tfunction blobSlice(blob, index, length) {\r\n\t\tif (index < 0 || length < 0 || index + length > blob.size)\r\n\t\t\tthrow new RangeError('offset:' + index + ', length:' + length + ', size:' + blob.size);\r\n\t\tif (blob.slice)\r\n\t\t\treturn blob.slice(index, index + length);\r\n\t\telse if (blob.webkitSlice)\r\n\t\t\treturn blob.webkitSlice(index, index + length);\r\n\t\telse if (blob.mozSlice)\r\n\t\t\treturn blob.mozSlice(index, index + length);\r\n\t\telse if (blob.msSlice)\r\n\t\t\treturn blob.msSlice(index, index + length);\r\n\t}\r\n\r\n\tfunction getDataHelper(byteLength, bytes) {\r\n\t\tvar dataBuffer, dataArray;\r\n\t\tdataBuffer = new ArrayBuffer(byteLength);\r\n\t\tdataArray = new Uint8Array(dataBuffer);\r\n\t\tif (bytes)\r\n\t\t\tdataArray.set(bytes, 0);\r\n\t\treturn {\r\n\t\t\tbuffer : dataBuffer,\r\n\t\t\tarray : dataArray,\r\n\t\t\tview : new DataView(dataBuffer)\r\n\t\t};\r\n\t}\r\n\r\n\t// Readers\r\n\tfunction Reader() {\r\n\t}\r\n\r\n\tfunction TextReader(text) {\r\n\t\tvar that = this, blobReader;\r\n\r\n\t\tfunction init(callback, onerror) {\r\n\t\t\tvar blob = new Blob([ text ], {\r\n\t\t\t\ttype : TEXT_PLAIN\r\n\t\t\t});\r\n\t\t\tblobReader = new BlobReader(blob);\r\n\t\t\tblobReader.init(function() {\r\n\t\t\t\tthat.size = blobReader.size;\r\n\t\t\t\tcallback();\r\n\t\t\t}, onerror);\r\n\t\t}\r\n\r\n\t\tfunction readUint8Array(index, length, callback, onerror) {\r\n\t\t\tblobReader.readUint8Array(index, length, callback, onerror);\r\n\t\t}\r\n\r\n\t\tthat.size = 0;\r\n\t\tthat.init = init;\r\n\t\tthat.readUint8Array = readUint8Array;\r\n\t}\r\n\tTextReader.prototype = new Reader();\r\n\tTextReader.prototype.constructor = TextReader;\r\n\r\n\tfunction Data64URIReader(dataURI) {\r\n\t\tvar that = this, dataStart;\r\n\r\n\t\tfunction init(callback) {\r\n\t\t\tvar dataEnd = dataURI.length;\r\n\t\t\twhile (dataURI.charAt(dataEnd - 1) == \"=\")\r\n\t\t\t\tdataEnd--;\r\n\t\t\tdataStart = dataURI.indexOf(\",\") + 1;\r\n\t\t\tthat.size = Math.floor((dataEnd - dataStart) * 0.75);\r\n\t\t\tcallback();\r\n\t\t}\r\n\r\n\t\tfunction readUint8Array(index, length, callback) {\r\n\t\t\tvar i, data = getDataHelper(length);\r\n\t\t\tvar start = Math.floor(index / 3) * 4;\r\n\t\t\tvar end = Math.ceil((index + length) / 3) * 4;\r\n\t\t\tvar bytes = obj.atob(dataURI.substring(start + dataStart, end + dataStart));\r\n\t\t\tvar delta = index - Math.floor(start / 4) * 3;\r\n\t\t\tfor (i = delta; i < delta + length; i++)\r\n\t\t\t\tdata.array[i - delta] = bytes.charCodeAt(i);\r\n\t\t\tcallback(data.array);\r\n\t\t}\r\n\r\n\t\tthat.size = 0;\r\n\t\tthat.init = init;\r\n\t\tthat.readUint8Array = readUint8Array;\r\n\t}\r\n\tData64URIReader.prototype = new Reader();\r\n\tData64URIReader.prototype.constructor = Data64URIReader;\r\n\r\n\tfunction BlobReader(blob) {\r\n\t\tvar that = this;\r\n\r\n\t\tfunction init(callback) {\r\n\t\t\tthat.size = blob.size;\r\n\t\t\tcallback();\r\n\t\t}\r\n\r\n\t\tfunction readUint8Array(index, length, callback, onerror) {\r\n\t\t\tvar reader = new FileReader();\r\n\t\t\treader.onload = function(e) {\r\n\t\t\t\tcallback(new Uint8Array(e.target.result));\r\n\t\t\t};\r\n\t\t\treader.onerror = onerror;\r\n\t\t\ttry {\r\n\t\t\t\treader.readAsArrayBuffer(blobSlice(blob, index, length));\r\n\t\t\t} catch (e) {\r\n\t\t\t\tonerror(e);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthat.size = 0;\r\n\t\tthat.init = init;\r\n\t\tthat.readUint8Array = readUint8Array;\r\n\t}\r\n\tBlobReader.prototype = new Reader();\r\n\tBlobReader.prototype.constructor = BlobReader;\r\n\r\n\t// Writers\r\n\r\n\tfunction Writer() {\r\n\t}\r\n\tWriter.prototype.getData = function(callback) {\r\n\t\tcallback(this.data);\r\n\t};\r\n\r\n\tfunction TextWriter(encoding) {\r\n\t\tvar that = this, blob;\r\n\r\n\t\tfunction init(callback) {\r\n\t\t\tblob = new Blob([], {\r\n\t\t\t\ttype : TEXT_PLAIN\r\n\t\t\t});\r\n\t\t\tcallback();\r\n\t\t}\r\n\r\n\t\tfunction writeUint8Array(array, callback) {\r\n\t\t\tblob = new Blob([ blob, appendABViewSupported ? array : array.buffer ], {\r\n\t\t\t\ttype : TEXT_PLAIN\r\n\t\t\t});\r\n\t\t\tcallback();\r\n\t\t}\r\n\r\n\t\tfunction getData(callback, onerror) {\r\n\t\t\tvar reader = new FileReader();\r\n\t\t\treader.onload = function(e) {\r\n\t\t\t\tcallback(e.target.result);\r\n\t\t\t};\r\n\t\t\treader.onerror = onerror;\r\n\t\t\treader.readAsText(blob, encoding);\r\n\t\t}\r\n\r\n\t\tthat.init = init;\r\n\t\tthat.writeUint8Array = writeUint8Array;\r\n\t\tthat.getData = getData;\r\n\t}\r\n\tTextWriter.prototype = new Writer();\r\n\tTextWriter.prototype.constructor = TextWriter;\r\n\r\n\tfunction Data64URIWriter(contentType) {\r\n\t\tvar that = this, data = \"\", pending = \"\";\r\n\r\n\t\tfunction init(callback) {\r\n\t\t\tdata += \"data:\" + (contentType || \"\") + \";base64,\";\r\n\t\t\tcallback();\r\n\t\t}\r\n\r\n\t\tfunction writeUint8Array(array, callback) {\r\n\t\t\tvar i, delta = pending.length, dataString = pending;\r\n\t\t\tpending = \"\";\r\n\t\t\tfor (i = 0; i < (Math.floor((delta + array.length) / 3) * 3) - delta; i++)\r\n\t\t\t\tdataString += String.fromCharCode(array[i]);\r\n\t\t\tfor (; i < array.length; i++)\r\n\t\t\t\tpending += String.fromCharCode(array[i]);\r\n\t\t\tif (dataString.length > 2)\r\n\t\t\t\tdata += obj.btoa(dataString);\r\n\t\t\telse\r\n\t\t\t\tpending = dataString;\r\n\t\t\tcallback();\r\n\t\t}\r\n\r\n\t\tfunction getData(callback) {\r\n\t\t\tcallback(data + obj.btoa(pending));\r\n\t\t}\r\n\r\n\t\tthat.init = init;\r\n\t\tthat.writeUint8Array = writeUint8Array;\r\n\t\tthat.getData = getData;\r\n\t}\r\n\tData64URIWriter.prototype = new Writer();\r\n\tData64URIWriter.prototype.constructor = Data64URIWriter;\r\n\r\n\tfunction BlobWriter(contentType) {\r\n\t\tvar data = [], that = this;\r\n\r\n\t\tfunction init(callback) {\r\n\t\t\tcallback();\r\n\t\t}\r\n\r\n\t\tfunction writeUint8Array(array, callback) {\r\n\t\t\tdata.push(appendABViewSupported ? array : array.buffer);\r\n\t\t\tcallback();\r\n\t\t}\r\n\r\n\t\tfunction getData(callback) {\r\n\t\t\tcallback(new Blob(data, {type: contentType}));\r\n\t\t}\r\n\r\n\t\tthat.init = init;\r\n\t\tthat.writeUint8Array = writeUint8Array;\r\n\t\tthat.getData = getData;\r\n\t}\r\n\tBlobWriter.prototype = new Writer();\r\n\tBlobWriter.prototype.constructor = BlobWriter;\r\n\r\n\t/** \r\n\t * inflate/deflate core functions\r\n\t * @param worker {Worker} web worker for the task.\r\n\t * @param initialMessage {Object} initial message to be sent to the worker. should contain\r\n\t *   sn(serial number for distinguishing multiple tasks sent to the worker), and codecClass.\r\n\t *   This function may add more properties before sending.\r\n\t */\r\n\tfunction launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror) {\r\n\t\tvar chunkIndex = 0, index, outputSize, sn = initialMessage.sn, crc;\r\n\r\n\t\tfunction onflush() {\r\n\t\t\tworker.removeEventListener('message', onmessage, false);\r\n\t\t\tonend(outputSize, crc);\r\n\t\t}\r\n\r\n\t\tfunction onmessage(event) {\r\n\t\t\tvar message = event.data, data = message.data, err = message.error;\r\n\t\t\tif (err) {\r\n\t\t\t\terr.toString = function () { return 'Error: ' + this.message; };\r\n\t\t\t\tonreaderror(err);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (message.sn !== sn)\r\n\t\t\t\treturn;\r\n\t\t\tif (typeof message.codecTime === 'number')\r\n\t\t\t\tworker.codecTime += message.codecTime; // should be before onflush()\r\n\t\t\tif (typeof message.crcTime === 'number')\r\n\t\t\t\tworker.crcTime += message.crcTime;\r\n\r\n\t\t\tswitch (message.type) {\r\n\t\t\t\tcase 'append':\r\n\t\t\t\t\tif (data) {\r\n\t\t\t\t\t\toutputSize += data.length;\r\n\t\t\t\t\t\twriter.writeUint8Array(data, function() {\r\n\t\t\t\t\t\t\tstep();\r\n\t\t\t\t\t\t}, onwriteerror);\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\tstep();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'flush':\r\n\t\t\t\t\tcrc = message.crc;\r\n\t\t\t\t\tif (data) {\r\n\t\t\t\t\t\toutputSize += data.length;\r\n\t\t\t\t\t\twriter.writeUint8Array(data, function() {\r\n\t\t\t\t\t\t\tonflush();\r\n\t\t\t\t\t\t}, onwriteerror);\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\tonflush();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'progress':\r\n\t\t\t\t\tif (onprogress)\r\n\t\t\t\t\t\tonprogress(index + message.loaded, size);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'importScripts': //no need to handle here\r\n\t\t\t\tcase 'newTask':\r\n\t\t\t\tcase 'echo':\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tconsole.warn('zip.js:launchWorkerProcess: unknown message: ', message);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction step() {\r\n\t\t\tindex = chunkIndex * CHUNK_SIZE;\r\n\t\t\tif (index < size) {\r\n\t\t\t\treader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(array) {\r\n\t\t\t\t\tif (onprogress)\r\n\t\t\t\t\t\tonprogress(index, size);\r\n\t\t\t\t\tvar msg = index === 0 ? initialMessage : {sn : sn};\r\n\t\t\t\t\tmsg.type = 'append';\r\n\t\t\t\t\tmsg.data = array;\r\n\t\t\t\t\tworker.postMessage(msg, [array.buffer]);\r\n\t\t\t\t\tchunkIndex++;\r\n\t\t\t\t}, onreaderror);\r\n\t\t\t} else {\r\n\t\t\t\tworker.postMessage({\r\n\t\t\t\t\tsn: sn,\r\n\t\t\t\t\ttype: 'flush'\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\toutputSize = 0;\r\n\t\tworker.addEventListener('message', onmessage, false);\r\n\t\tstep();\r\n\t}\r\n\r\n\tfunction launchProcess(process, reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror) {\r\n\t\tvar chunkIndex = 0, index, outputSize = 0,\r\n\t\t\tcrcInput = crcType === 'input',\r\n\t\t\tcrcOutput = crcType === 'output',\r\n\t\t\tcrc = new Crc32();\r\n\t\tfunction step() {\r\n\t\t\tvar outputData;\r\n\t\t\tindex = chunkIndex * CHUNK_SIZE;\r\n\t\t\tif (index < size)\r\n\t\t\t\treader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(inputData) {\r\n\t\t\t\t\tvar outputData;\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\toutputData = process.append(inputData, function(loaded) {\r\n\t\t\t\t\t\t\tif (onprogress)\r\n\t\t\t\t\t\t\t\tonprogress(index + loaded, size);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\tonreaderror(e);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (outputData) {\r\n\t\t\t\t\t\toutputSize += outputData.length;\r\n\t\t\t\t\t\twriter.writeUint8Array(outputData, function() {\r\n\t\t\t\t\t\t\tchunkIndex++;\r\n\t\t\t\t\t\t\tsetTimeout(step, 1);\r\n\t\t\t\t\t\t}, onwriteerror);\r\n\t\t\t\t\t\tif (crcOutput)\r\n\t\t\t\t\t\t\tcrc.append(outputData);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tchunkIndex++;\r\n\t\t\t\t\t\tsetTimeout(step, 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (crcInput)\r\n\t\t\t\t\t\tcrc.append(inputData);\r\n\t\t\t\t\tif (onprogress)\r\n\t\t\t\t\t\tonprogress(index, size);\r\n\t\t\t\t}, onreaderror);\r\n\t\t\telse {\r\n\t\t\t\ttry {\r\n\t\t\t\t\toutputData = process.flush();\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tonreaderror(e);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tif (outputData) {\r\n\t\t\t\t\tif (crcOutput)\r\n\t\t\t\t\t\tcrc.append(outputData);\r\n\t\t\t\t\toutputSize += outputData.length;\r\n\t\t\t\t\twriter.writeUint8Array(outputData, function() {\r\n\t\t\t\t\t\tonend(outputSize, crc.get());\r\n\t\t\t\t\t}, onwriteerror);\r\n\t\t\t\t} else\r\n\t\t\t\t\tonend(outputSize, crc.get());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tstep();\r\n\t}\r\n\r\n\tfunction inflate(worker, sn, reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {\r\n\t\tvar crcType = computeCrc32 ? 'output' : 'none';\r\n\t\tif (obj.zip.useWebWorkers) {\r\n\t\t\tvar initialMessage = {\r\n\t\t\t\tsn: sn,\r\n\t\t\t\tcodecClass: 'Inflater',\r\n\t\t\t\tcrcType: crcType,\r\n\t\t\t};\r\n\t\t\tlaunchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror);\r\n\t\t} else\r\n\t\t\tlaunchProcess(new obj.zip.Inflater(), reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror);\r\n\t}\r\n\r\n\tfunction deflate(worker, sn, reader, writer, level, onend, onprogress, onreaderror, onwriteerror) {\r\n\t\tvar crcType = 'input';\r\n\t\tif (obj.zip.useWebWorkers) {\r\n\t\t\tvar initialMessage = {\r\n\t\t\t\tsn: sn,\r\n\t\t\t\toptions: {level: level},\r\n\t\t\t\tcodecClass: 'Deflater',\r\n\t\t\t\tcrcType: crcType,\r\n\t\t\t};\r\n\t\t\tlaunchWorkerProcess(worker, initialMessage, reader, writer, 0, reader.size, onprogress, onend, onreaderror, onwriteerror);\r\n\t\t} else\r\n\t\t\tlaunchProcess(new obj.zip.Deflater(), reader, writer, 0, reader.size, crcType, onprogress, onend, onreaderror, onwriteerror);\r\n\t}\r\n\r\n\tfunction copy(worker, sn, reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {\r\n\t\tvar crcType = 'input';\r\n\t\tif (obj.zip.useWebWorkers && computeCrc32) {\r\n\t\t\tvar initialMessage = {\r\n\t\t\t\tsn: sn,\r\n\t\t\t\tcodecClass: 'NOOP',\r\n\t\t\t\tcrcType: crcType,\r\n\t\t\t};\r\n\t\t\tlaunchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror);\r\n\t\t} else\r\n\t\t\tlaunchProcess(new NOOP(), reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror);\r\n\t}\r\n\r\n\t// ZipReader\r\n\r\n\tfunction decodeASCII(str) {\r\n\t\tvar i, out = \"\", charCode, extendedASCII = [ '\\u00C7', '\\u00FC', '\\u00E9', '\\u00E2', '\\u00E4', '\\u00E0', '\\u00E5', '\\u00E7', '\\u00EA', '\\u00EB',\r\n\t\t\t\t'\\u00E8', '\\u00EF', '\\u00EE', '\\u00EC', '\\u00C4', '\\u00C5', '\\u00C9', '\\u00E6', '\\u00C6', '\\u00F4', '\\u00F6', '\\u00F2', '\\u00FB', '\\u00F9',\r\n\t\t\t\t'\\u00FF', '\\u00D6', '\\u00DC', '\\u00F8', '\\u00A3', '\\u00D8', '\\u00D7', '\\u0192', '\\u00E1', '\\u00ED', '\\u00F3', '\\u00FA', '\\u00F1', '\\u00D1',\r\n\t\t\t\t'\\u00AA', '\\u00BA', '\\u00BF', '\\u00AE', '\\u00AC', '\\u00BD', '\\u00BC', '\\u00A1', '\\u00AB', '\\u00BB', '_', '_', '_', '\\u00A6', '\\u00A6',\r\n\t\t\t\t'\\u00C1', '\\u00C2', '\\u00C0', '\\u00A9', '\\u00A6', '\\u00A6', '+', '+', '\\u00A2', '\\u00A5', '+', '+', '-', '-', '+', '-', '+', '\\u00E3',\r\n\t\t\t\t'\\u00C3', '+', '+', '-', '-', '\\u00A6', '-', '+', '\\u00A4', '\\u00F0', '\\u00D0', '\\u00CA', '\\u00CB', '\\u00C8', 'i', '\\u00CD', '\\u00CE',\r\n\t\t\t\t'\\u00CF', '+', '+', '_', '_', '\\u00A6', '\\u00CC', '_', '\\u00D3', '\\u00DF', '\\u00D4', '\\u00D2', '\\u00F5', '\\u00D5', '\\u00B5', '\\u00FE',\r\n\t\t\t\t'\\u00DE', '\\u00DA', '\\u00DB', '\\u00D9', '\\u00FD', '\\u00DD', '\\u00AF', '\\u00B4', '\\u00AD', '\\u00B1', '_', '\\u00BE', '\\u00B6', '\\u00A7',\r\n\t\t\t\t'\\u00F7', '\\u00B8', '\\u00B0', '\\u00A8', '\\u00B7', '\\u00B9', '\\u00B3', '\\u00B2', '_', ' ' ];\r\n\t\tfor (i = 0; i < str.length; i++) {\r\n\t\t\tcharCode = str.charCodeAt(i) & 0xFF;\r\n\t\t\tif (charCode > 127)\r\n\t\t\t\tout += extendedASCII[charCode - 128];\r\n\t\t\telse\r\n\t\t\t\tout += String.fromCharCode(charCode);\r\n\t\t}\r\n\t\treturn out;\r\n\t}\r\n\r\n\tfunction decodeUTF8(string) {\r\n\t\treturn decodeURIComponent(escape(string));\r\n\t}\r\n\r\n\tfunction getString(bytes) {\r\n\t\tvar i, str = \"\";\r\n\t\tfor (i = 0; i < bytes.length; i++)\r\n\t\t\tstr += String.fromCharCode(bytes[i]);\r\n\t\treturn str;\r\n\t}\r\n\r\n\tfunction getDate(timeRaw) {\r\n\t\tvar date = (timeRaw & 0xffff0000) >> 16, time = timeRaw & 0x0000ffff;\r\n\t\ttry {\r\n\t\t\treturn new Date(1980 + ((date & 0xFE00) >> 9), ((date & 0x01E0) >> 5) - 1, date & 0x001F, (time & 0xF800) >> 11, (time & 0x07E0) >> 5,\r\n\t\t\t\t\t(time & 0x001F) * 2, 0);\r\n\t\t} catch (e) {\r\n\t\t}\r\n\t}\r\n\r\n\tfunction readCommonHeader(entry, data, index, centralDirectory, onerror) {\r\n\t\tentry.version = data.view.getUint16(index, true);\r\n\t\tentry.bitFlag = data.view.getUint16(index + 2, true);\r\n\t\tentry.compressionMethod = data.view.getUint16(index + 4, true);\r\n\t\tentry.lastModDateRaw = data.view.getUint32(index + 6, true);\r\n\t\tentry.lastModDate = getDate(entry.lastModDateRaw);\r\n\t\tif ((entry.bitFlag & 0x01) === 0x01) {\r\n\t\t\tonerror(ERR_ENCRYPTED);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (centralDirectory || (entry.bitFlag & 0x0008) != 0x0008) {\r\n\t\t\tentry.crc32 = data.view.getUint32(index + 10, true);\r\n\t\t\tentry.compressedSize = data.view.getUint32(index + 14, true);\r\n\t\t\tentry.uncompressedSize = data.view.getUint32(index + 18, true);\r\n\t\t}\r\n\t\tif (entry.compressedSize === 0xFFFFFFFF || entry.uncompressedSize === 0xFFFFFFFF) {\r\n\t\t\tonerror(ERR_ZIP64);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tentry.filenameLength = data.view.getUint16(index + 22, true);\r\n\t\tentry.extraFieldLength = data.view.getUint16(index + 24, true);\r\n\t}\r\n\r\n\tfunction createZipReader(reader, callback, onerror) {\r\n\t\tvar inflateSN = 0;\r\n\r\n\t\tfunction Entry() {\r\n\t\t}\r\n\r\n\t\tEntry.prototype.getData = function(writer, onend, onprogress, checkCrc32) {\r\n\t\t\tvar that = this;\r\n\r\n\t\t\tfunction testCrc32(crc32) {\r\n\t\t\t\tvar dataCrc32 = getDataHelper(4);\r\n\t\t\t\tdataCrc32.view.setUint32(0, crc32);\r\n\t\t\t\treturn that.crc32 == dataCrc32.view.getUint32(0);\r\n\t\t\t}\r\n\r\n\t\t\tfunction getWriterData(uncompressedSize, crc32) {\r\n\t\t\t\tif (checkCrc32 && !testCrc32(crc32))\r\n\t\t\t\t\tonerror(ERR_CRC);\r\n\t\t\t\telse\r\n\t\t\t\t\twriter.getData(function(data) {\r\n\t\t\t\t\t\tonend(data);\r\n\t\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tfunction onreaderror(err) {\r\n\t\t\t\tonerror(err || ERR_READ_DATA);\r\n\t\t\t}\r\n\r\n\t\t\tfunction onwriteerror(err) {\r\n\t\t\t\tonerror(err || ERR_WRITE_DATA);\r\n\t\t\t}\r\n\r\n\t\t\treader.readUint8Array(that.offset, 30, function(bytes) {\r\n\t\t\t\tvar data = getDataHelper(bytes.length, bytes), dataOffset;\r\n\t\t\t\tif (data.view.getUint32(0) != 0x504b0304) {\r\n\t\t\t\t\tonerror(ERR_BAD_FORMAT);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\treadCommonHeader(that, data, 4, false, onerror);\r\n\t\t\t\tdataOffset = that.offset + 30 + that.filenameLength + that.extraFieldLength;\r\n\t\t\t\twriter.init(function() {\r\n\t\t\t\t\tif (that.compressionMethod === 0)\r\n\t\t\t\t\t\tcopy(that._worker, inflateSN++, reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinflate(that._worker, inflateSN++, reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror);\r\n\t\t\t\t}, onwriteerror);\r\n\t\t\t}, onreaderror);\r\n\t\t};\r\n\r\n\t\tfunction seekEOCDR(eocdrCallback) {\r\n\t\t\t// \"End of central directory record\" is the last part of a zip archive, and is at least 22 bytes long.\r\n\t\t\t// Zip file comment is the last part of EOCDR and has max length of 64KB,\r\n\t\t\t// so we only have to search the last 64K + 22 bytes of a archive for EOCDR signature (0x06054b50).\r\n\t\t\tvar EOCDR_MIN = 22;\r\n\t\t\tif (reader.size < EOCDR_MIN) {\r\n\t\t\t\tonerror(ERR_BAD_FORMAT);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar ZIP_COMMENT_MAX = 256 * 256, EOCDR_MAX = EOCDR_MIN + ZIP_COMMENT_MAX;\r\n\r\n\t\t\t// In most cases, the EOCDR is EOCDR_MIN bytes long\r\n\t\t\tdoSeek(EOCDR_MIN, function() {\r\n\t\t\t\t// If not found, try within EOCDR_MAX bytes\r\n\t\t\t\tdoSeek(Math.min(EOCDR_MAX, reader.size), function() {\r\n\t\t\t\t\tonerror(ERR_BAD_FORMAT);\r\n\t\t\t\t});\r\n\t\t\t});\r\n\r\n\t\t\t// seek last length bytes of file for EOCDR\r\n\t\t\tfunction doSeek(length, eocdrNotFoundCallback) {\r\n\t\t\t\treader.readUint8Array(reader.size - length, length, function(bytes) {\r\n\t\t\t\t\tfor (var i = bytes.length - EOCDR_MIN; i >= 0; i--) {\r\n\t\t\t\t\t\tif (bytes[i] === 0x50 && bytes[i + 1] === 0x4b && bytes[i + 2] === 0x05 && bytes[i + 3] === 0x06) {\r\n\t\t\t\t\t\t\teocdrCallback(new DataView(bytes.buffer, i, EOCDR_MIN));\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\teocdrNotFoundCallback();\r\n\t\t\t\t}, function() {\r\n\t\t\t\t\tonerror(ERR_READ);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar zipReader = {\r\n\t\t\tgetEntries : function(callback) {\r\n\t\t\t\tvar worker = this._worker;\r\n\t\t\t\t// look for End of central directory record\r\n\t\t\t\tseekEOCDR(function(dataView) {\r\n\t\t\t\t\tvar datalength, fileslength;\r\n\t\t\t\t\tdatalength = dataView.getUint32(16, true);\r\n\t\t\t\t\tfileslength = dataView.getUint16(8, true);\r\n\t\t\t\t\tif (datalength < 0 || datalength >= reader.size) {\r\n\t\t\t\t\t\tonerror(ERR_BAD_FORMAT);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treader.readUint8Array(datalength, reader.size - datalength, function(bytes) {\r\n\t\t\t\t\t\tvar i, index = 0, entries = [], entry, filename, comment, data = getDataHelper(bytes.length, bytes);\r\n\t\t\t\t\t\tfor (i = 0; i < fileslength; i++) {\r\n\t\t\t\t\t\t\tentry = new Entry();\r\n\t\t\t\t\t\t\tentry._worker = worker;\r\n\t\t\t\t\t\t\tif (data.view.getUint32(index) != 0x504b0102) {\r\n\t\t\t\t\t\t\t\tonerror(ERR_BAD_FORMAT);\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treadCommonHeader(entry, data, index + 6, true, onerror);\r\n\t\t\t\t\t\t\tentry.commentLength = data.view.getUint16(index + 32, true);\r\n\t\t\t\t\t\t\tentry.directory = ((data.view.getUint8(index + 38) & 0x10) == 0x10);\r\n\t\t\t\t\t\t\tentry.offset = data.view.getUint32(index + 42, true);\r\n\t\t\t\t\t\t\tfilename = getString(data.array.subarray(index + 46, index + 46 + entry.filenameLength));\r\n\t\t\t\t\t\t\tentry.filename = ((entry.bitFlag & 0x0800) === 0x0800) ? decodeUTF8(filename) : decodeASCII(filename);\r\n\t\t\t\t\t\t\tif (!entry.directory && entry.filename.charAt(entry.filename.length - 1) == \"/\")\r\n\t\t\t\t\t\t\t\tentry.directory = true;\r\n\t\t\t\t\t\t\tcomment = getString(data.array.subarray(index + 46 + entry.filenameLength + entry.extraFieldLength, index + 46\r\n\t\t\t\t\t\t\t\t\t+ entry.filenameLength + entry.extraFieldLength + entry.commentLength));\r\n\t\t\t\t\t\t\tentry.comment = ((entry.bitFlag & 0x0800) === 0x0800) ? decodeUTF8(comment) : decodeASCII(comment);\r\n\t\t\t\t\t\t\tentries.push(entry);\r\n\t\t\t\t\t\t\tindex += 46 + entry.filenameLength + entry.extraFieldLength + entry.commentLength;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcallback(entries);\r\n\t\t\t\t\t}, function() {\r\n\t\t\t\t\t\tonerror(ERR_READ);\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t},\r\n\t\t\tclose : function(callback) {\r\n\t\t\t\tif (this._worker) {\r\n\t\t\t\t\tthis._worker.terminate();\r\n\t\t\t\t\tthis._worker = null;\r\n\t\t\t\t}\r\n\t\t\t\tif (callback)\r\n\t\t\t\t\tcallback();\r\n\t\t\t},\r\n\t\t\t_worker: null\r\n\t\t};\r\n\r\n\t\tif (!obj.zip.useWebWorkers)\r\n\t\t\tcallback(zipReader);\r\n\t\telse {\r\n\t\t\tcreateWorker('inflater',\r\n\t\t\t\tfunction(worker) {\r\n\t\t\t\t\tzipReader._worker = worker;\r\n\t\t\t\t\tcallback(zipReader);\r\n\t\t\t\t},\r\n\t\t\t\tfunction(err) {\r\n\t\t\t\t\tonerror(err);\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\t// ZipWriter\r\n\r\n\tfunction encodeUTF8(string) {\r\n\t\treturn unescape(encodeURIComponent(string));\r\n\t}\r\n\r\n\tfunction getBytes(str) {\r\n\t\tvar i, array = [];\r\n\t\tfor (i = 0; i < str.length; i++)\r\n\t\t\tarray.push(str.charCodeAt(i));\r\n\t\treturn array;\r\n\t}\r\n\r\n\tfunction createZipWriter(writer, callback, onerror, dontDeflate) {\r\n\t\tvar files = {}, filenames = [], datalength = 0;\r\n\t\tvar deflateSN = 0;\r\n\r\n\t\tfunction onwriteerror(err) {\r\n\t\t\tonerror(err || ERR_WRITE);\r\n\t\t}\r\n\r\n\t\tfunction onreaderror(err) {\r\n\t\t\tonerror(err || ERR_READ_DATA);\r\n\t\t}\r\n\r\n\t\tvar zipWriter = {\r\n\t\t\tadd : function(name, reader, onend, onprogress, options) {\r\n\t\t\t\tvar header, filename, date;\r\n\t\t\t\tvar worker = this._worker;\r\n\r\n\t\t\t\tfunction writeHeader(callback) {\r\n\t\t\t\t\tvar data;\r\n\t\t\t\t\tdate = options.lastModDate || new Date();\r\n\t\t\t\t\theader = getDataHelper(26);\r\n\t\t\t\t\tfiles[name] = {\r\n\t\t\t\t\t\theaderArray : header.array,\r\n\t\t\t\t\t\tdirectory : options.directory,\r\n\t\t\t\t\t\tfilename : filename,\r\n\t\t\t\t\t\toffset : datalength,\r\n\t\t\t\t\t\tcomment : getBytes(encodeUTF8(options.comment || \"\"))\r\n\t\t\t\t\t};\r\n\t\t\t\t\theader.view.setUint32(0, 0x14000808);\r\n\t\t\t\t\tif (options.version)\r\n\t\t\t\t\t\theader.view.setUint8(0, options.version);\r\n\t\t\t\t\tif (!dontDeflate && options.level !== 0 && !options.directory)\r\n\t\t\t\t\t\theader.view.setUint16(4, 0x0800);\r\n\t\t\t\t\theader.view.setUint16(6, (((date.getHours() << 6) | date.getMinutes()) << 5) | date.getSeconds() / 2, true);\r\n\t\t\t\t\theader.view.setUint16(8, ((((date.getFullYear() - 1980) << 4) | (date.getMonth() + 1)) << 5) | date.getDate(), true);\r\n\t\t\t\t\theader.view.setUint16(22, filename.length, true);\r\n\t\t\t\t\tdata = getDataHelper(30 + filename.length);\r\n\t\t\t\t\tdata.view.setUint32(0, 0x504b0304);\r\n\t\t\t\t\tdata.array.set(header.array, 4);\r\n\t\t\t\t\tdata.array.set(filename, 30);\r\n\t\t\t\t\tdatalength += data.array.length;\r\n\t\t\t\t\twriter.writeUint8Array(data.array, callback, onwriteerror);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction writeFooter(compressedLength, crc32) {\r\n\t\t\t\t\tvar footer = getDataHelper(16);\r\n\t\t\t\t\tdatalength += compressedLength || 0;\r\n\t\t\t\t\tfooter.view.setUint32(0, 0x504b0708);\r\n\t\t\t\t\tif (typeof crc32 != \"undefined\") {\r\n\t\t\t\t\t\theader.view.setUint32(10, crc32, true);\r\n\t\t\t\t\t\tfooter.view.setUint32(4, crc32, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (reader) {\r\n\t\t\t\t\t\tfooter.view.setUint32(8, compressedLength, true);\r\n\t\t\t\t\t\theader.view.setUint32(14, compressedLength, true);\r\n\t\t\t\t\t\tfooter.view.setUint32(12, reader.size, true);\r\n\t\t\t\t\t\theader.view.setUint32(18, reader.size, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t\twriter.writeUint8Array(footer.array, function() {\r\n\t\t\t\t\t\tdatalength += 16;\r\n\t\t\t\t\t\tonend();\r\n\t\t\t\t\t}, onwriteerror);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction writeFile() {\r\n\t\t\t\t\toptions = options || {};\r\n\t\t\t\t\tname = name.trim();\r\n\t\t\t\t\tif (options.directory && name.charAt(name.length - 1) != \"/\")\r\n\t\t\t\t\t\tname += \"/\";\r\n\t\t\t\t\tif (files.hasOwnProperty(name)) {\r\n\t\t\t\t\t\tonerror(ERR_DUPLICATED_NAME);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfilename = getBytes(encodeUTF8(name));\r\n\t\t\t\t\tfilenames.push(name);\r\n\t\t\t\t\twriteHeader(function() {\r\n\t\t\t\t\t\tif (reader)\r\n\t\t\t\t\t\t\tif (dontDeflate || options.level === 0)\r\n\t\t\t\t\t\t\t\tcopy(worker, deflateSN++, reader, writer, 0, reader.size, true, writeFooter, onprogress, onreaderror, onwriteerror);\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\tdeflate(worker, deflateSN++, reader, writer, options.level, writeFooter, onprogress, onreaderror, onwriteerror);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\twriteFooter();\r\n\t\t\t\t\t}, onwriteerror);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (reader)\r\n\t\t\t\t\treader.init(writeFile, onreaderror);\r\n\t\t\t\telse\r\n\t\t\t\t\twriteFile();\r\n\t\t\t},\r\n\t\t\tclose : function(callback) {\r\n\t\t\t\tif (this._worker) {\r\n\t\t\t\t\tthis._worker.terminate();\r\n\t\t\t\t\tthis._worker = null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar data, length = 0, index = 0, indexFilename, file;\r\n\t\t\t\tfor (indexFilename = 0; indexFilename < filenames.length; indexFilename++) {\r\n\t\t\t\t\tfile = files[filenames[indexFilename]];\r\n\t\t\t\t\tlength += 46 + file.filename.length + file.comment.length;\r\n\t\t\t\t}\r\n\t\t\t\tdata = getDataHelper(length + 22);\r\n\t\t\t\tfor (indexFilename = 0; indexFilename < filenames.length; indexFilename++) {\r\n\t\t\t\t\tfile = files[filenames[indexFilename]];\r\n\t\t\t\t\tdata.view.setUint32(index, 0x504b0102);\r\n\t\t\t\t\tdata.view.setUint16(index + 4, 0x1400);\r\n\t\t\t\t\tdata.array.set(file.headerArray, index + 6);\r\n\t\t\t\t\tdata.view.setUint16(index + 32, file.comment.length, true);\r\n\t\t\t\t\tif (file.directory)\r\n\t\t\t\t\t\tdata.view.setUint8(index + 38, 0x10);\r\n\t\t\t\t\tdata.view.setUint32(index + 42, file.offset, true);\r\n\t\t\t\t\tdata.array.set(file.filename, index + 46);\r\n\t\t\t\t\tdata.array.set(file.comment, index + 46 + file.filename.length);\r\n\t\t\t\t\tindex += 46 + file.filename.length + file.comment.length;\r\n\t\t\t\t}\r\n\t\t\t\tdata.view.setUint32(index, 0x504b0506);\r\n\t\t\t\tdata.view.setUint16(index + 8, filenames.length, true);\r\n\t\t\t\tdata.view.setUint16(index + 10, filenames.length, true);\r\n\t\t\t\tdata.view.setUint32(index + 12, length, true);\r\n\t\t\t\tdata.view.setUint32(index + 16, datalength, true);\r\n\t\t\t\twriter.writeUint8Array(data.array, function() {\r\n\t\t\t\t\twriter.getData(callback);\r\n\t\t\t\t}, onwriteerror);\r\n\t\t\t},\r\n\t\t\t_worker: null\r\n\t\t};\r\n\r\n\t\tif (!obj.zip.useWebWorkers)\r\n\t\t\tcallback(zipWriter);\r\n\t\telse {\r\n\t\t\tcreateWorker('deflater',\r\n\t\t\t\tfunction(worker) {\r\n\t\t\t\t\tzipWriter._worker = worker;\r\n\t\t\t\t\tcallback(zipWriter);\r\n\t\t\t\t},\r\n\t\t\t\tfunction(err) {\r\n\t\t\t\t\tonerror(err);\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction resolveURLs(urls) {\r\n\t\tvar a = document.createElement('a');\r\n\t\treturn urls.map(function(url) {\r\n\t\t\ta.href = url;\r\n\t\t\treturn a.href;\r\n\t\t});\r\n\t}\r\n\r\n\tvar DEFAULT_WORKER_SCRIPTS = {\r\n\t\tdeflater: ['z-worker.js', 'deflate.js'],\r\n\t\tinflater: ['z-worker.js', 'inflate.js']\r\n\t};\r\n\tfunction createWorker(type, callback, onerror) {\r\n\t\tif (obj.zip.workerScripts !== null && obj.zip.workerScriptsPath !== null) {\r\n\t\t\tonerror(new Error('Either zip.workerScripts or zip.workerScriptsPath may be set, not both.'));\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvar scripts;\r\n\t\tif (obj.zip.workerScripts) {\r\n\t\t\tscripts = obj.zip.workerScripts[type];\r\n\t\t\tif (!Array.isArray(scripts)) {\r\n\t\t\t\tonerror(new Error('zip.workerScripts.' + type + ' is not an array!'));\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tscripts = resolveURLs(scripts);\r\n\t\t} else {\r\n\t\t\tscripts = DEFAULT_WORKER_SCRIPTS[type].slice(0);\r\n\t\t\tscripts[0] = (obj.zip.workerScriptsPath || '') + scripts[0];\r\n\t\t}\r\n\t\tvar worker = new Worker(scripts[0]);\r\n\t\t// record total consumed time by inflater/deflater/crc32 in this worker\r\n\t\tworker.codecTime = worker.crcTime = 0;\r\n\t\tworker.postMessage({ type: 'importScripts', scripts: scripts.slice(1) });\r\n\t\tworker.addEventListener('message', onmessage);\r\n\t\tfunction onmessage(ev) {\r\n\t\t\tvar msg = ev.data;\r\n\t\t\tif (msg.error) {\r\n\t\t\t\tworker.terminate(); // should before onerror(), because onerror() may throw.\r\n\t\t\t\tonerror(msg.error);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (msg.type === 'importScripts') {\r\n\t\t\t\tworker.removeEventListener('message', onmessage);\r\n\t\t\t\tworker.removeEventListener('error', errorHandler);\r\n\t\t\t\tcallback(worker);\r\n\t\t\t}\r\n\t\t}\r\n\t\t// catch entry script loading error and other unhandled errors\r\n\t\tworker.addEventListener('error', errorHandler);\r\n\t\tfunction errorHandler(err) {\r\n\t\t\tworker.terminate();\r\n\t\t\tonerror(err);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction onerror_default(error) {\r\n\t\tconsole.error(error);\r\n\t}\r\n\tobj.zip = {\r\n\t\tReader : Reader,\r\n\t\tWriter : Writer,\r\n\t\tBlobReader : BlobReader,\r\n\t\tData64URIReader : Data64URIReader,\r\n\t\tTextReader : TextReader,\r\n\t\tBlobWriter : BlobWriter,\r\n\t\tData64URIWriter : Data64URIWriter,\r\n\t\tTextWriter : TextWriter,\r\n\t\tcreateReader : function(reader, callback, onerror) {\r\n\t\t\tonerror = onerror || onerror_default;\r\n\r\n\t\t\treader.init(function() {\r\n\t\t\t\tcreateZipReader(reader, callback, onerror);\r\n\t\t\t}, onerror);\r\n\t\t},\r\n\t\tcreateWriter : function(writer, callback, onerror, dontDeflate) {\r\n\t\t\tonerror = onerror || onerror_default;\r\n\t\t\tdontDeflate = !!dontDeflate;\r\n\r\n\t\t\twriter.init(function() {\r\n\t\t\t\tcreateZipWriter(writer, callback, onerror, dontDeflate);\r\n\t\t\t}, onerror);\r\n\t\t},\r\n\t\tuseWebWorkers : true,\r\n\t\t/**\r\n\t\t * Directory containing the default worker scripts (z-worker.js, deflate.js, and inflate.js), relative to current base url.\r\n\t\t * E.g.: zip.workerScripts = './';\r\n\t\t */\r\n\t\tworkerScriptsPath : null,\r\n\t\t/**\r\n\t\t * Advanced option to control which scripts are loaded in the Web worker. If this option is specified, then workerScriptsPath must not be set.\r\n\t\t * workerScripts.deflater/workerScripts.inflater should be arrays of urls to scripts for deflater/inflater, respectively.\r\n\t\t * Scripts in the array are executed in order, and the first one should be z-worker.js, which is used to start the worker.\r\n\t\t * All urls are relative to current base url.\r\n\t\t * E.g.:\r\n\t\t * zip.workerScripts = {\r\n\t\t *   deflater: ['z-worker.js', 'deflate.js'],\r\n\t\t *   inflater: ['z-worker.js', 'inflate.js']\r\n\t\t * };\r\n\t\t */\r\n\t\tworkerScripts : null,\r\n\t};\r\n\r\n})(this);\r\n\ndefine(\"zip\", (function (global) {\n    return function () {\n        var ret, fn;\n        return ret || global.zip;\n    };\n}(this)));\n\n",
    "/*\r\n Copyright (c) 2013 Gildas Lormeau. All rights reserved.\r\n\r\n Redistribution and use in source and binary forms, with or without\r\n modification, are permitted provided that the following conditions are met:\r\n\r\n 1. Redistributions of source code must retain the above copyright notice,\r\n this list of conditions and the following disclaimer.\r\n\r\n 2. Redistributions in binary form must reproduce the above copyright \r\n notice, this list of conditions and the following disclaimer in \r\n the documentation and/or other materials provided with the distribution.\r\n\r\n 3. The names of the authors may not be used to endorse or promote products\r\n derived from this software without specific prior written permission.\r\n\r\n THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\r\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\r\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\r\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\r\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\r\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\r\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\r\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\r\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n(function() {\r\n\t\"use strict\";\r\n\r\n\tvar CHUNK_SIZE = 512 * 1024;\r\n\r\n\tvar TextWriter = zip.TextWriter, //\r\n\tBlobWriter = zip.BlobWriter, //\r\n\tData64URIWriter = zip.Data64URIWriter, //\r\n\tReader = zip.Reader, //\r\n\tTextReader = zip.TextReader, //\r\n\tBlobReader = zip.BlobReader, //\r\n\tData64URIReader = zip.Data64URIReader, //\r\n\tcreateReader = zip.createReader, //\r\n\tcreateWriter = zip.createWriter;\r\n\r\n\tfunction ZipBlobReader(entry) {\r\n\t\tvar that = this, blobReader;\r\n\r\n\t\tfunction init(callback) {\r\n\t\t\tthat.size = entry.uncompressedSize;\r\n\t\t\tcallback();\r\n\t\t}\r\n\r\n\t\tfunction getData(callback) {\r\n\t\t\tif (that.data)\r\n\t\t\t\tcallback();\r\n\t\t\telse\r\n\t\t\t\tentry.getData(new BlobWriter(), function(data) {\r\n\t\t\t\t\tthat.data = data;\r\n\t\t\t\t\tblobReader = new BlobReader(data);\r\n\t\t\t\t\tcallback();\r\n\t\t\t\t}, null, that.checkCrc32);\r\n\t\t}\r\n\r\n\t\tfunction readUint8Array(index, length, callback, onerror) {\r\n\t\t\tgetData(function() {\r\n\t\t\t\tblobReader.readUint8Array(index, length, callback, onerror);\r\n\t\t\t}, onerror);\r\n\t\t}\r\n\r\n\t\tthat.size = 0;\r\n\t\tthat.init = init;\r\n\t\tthat.readUint8Array = readUint8Array;\r\n\t}\r\n\tZipBlobReader.prototype = new Reader();\r\n\tZipBlobReader.prototype.constructor = ZipBlobReader;\r\n\tZipBlobReader.prototype.checkCrc32 = false;\r\n\r\n\tfunction getTotalSize(entry) {\r\n\t\tvar size = 0;\r\n\r\n\t\tfunction process(entry) {\r\n\t\t\tsize += entry.uncompressedSize || 0;\r\n\t\t\tentry.children.forEach(process);\r\n\t\t}\r\n\r\n\t\tprocess(entry);\r\n\t\treturn size;\r\n\t}\r\n\r\n\tfunction initReaders(entry, onend, onerror) {\r\n\t\tvar index = 0;\r\n\r\n\t\tfunction next() {\r\n\t\t\tindex++;\r\n\t\t\tif (index < entry.children.length)\r\n\t\t\t\tprocess(entry.children[index]);\r\n\t\t\telse\r\n\t\t\t\tonend();\r\n\t\t}\r\n\r\n\t\tfunction process(child) {\r\n\t\t\tif (child.directory)\r\n\t\t\t\tinitReaders(child, next, onerror);\r\n\t\t\telse {\r\n\t\t\t\tchild.reader = new child.Reader(child.data, onerror);\r\n\t\t\t\tchild.reader.init(function() {\r\n\t\t\t\t\tchild.uncompressedSize = child.reader.size;\r\n\t\t\t\t\tnext();\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (entry.children.length)\r\n\t\t\tprocess(entry.children[index]);\r\n\t\telse\r\n\t\t\tonend();\r\n\t}\r\n\r\n\tfunction detach(entry) {\r\n\t\tvar children = entry.parent.children;\r\n\t\tchildren.forEach(function(child, index) {\r\n\t\t\tif (child.id == entry.id)\r\n\t\t\t\tchildren.splice(index, 1);\r\n\t\t});\r\n\t}\r\n\r\n\tfunction exportZip(zipWriter, entry, onend, onprogress, totalSize) {\r\n\t\tvar currentIndex = 0;\r\n\r\n\t\tfunction process(zipWriter, entry, onend, onprogress, totalSize) {\r\n\t\t\tvar childIndex = 0;\r\n\r\n\t\t\tfunction exportChild() {\r\n\t\t\t\tvar child = entry.children[childIndex];\r\n\t\t\t\tif (child)\r\n\t\t\t\t\tzipWriter.add(child.getFullname(), child.reader, function() {\r\n\t\t\t\t\t\tcurrentIndex += child.uncompressedSize || 0;\r\n\t\t\t\t\t\tprocess(zipWriter, child, function() {\r\n\t\t\t\t\t\t\tchildIndex++;\r\n\t\t\t\t\t\t\texportChild();\r\n\t\t\t\t\t\t}, onprogress, totalSize);\r\n\t\t\t\t\t}, function(index) {\r\n\t\t\t\t\t\tif (onprogress)\r\n\t\t\t\t\t\t\tonprogress(currentIndex + index, totalSize);\r\n\t\t\t\t\t}, {\r\n\t\t\t\t\t\tdirectory : child.directory,\r\n\t\t\t\t\t\tversion : child.zipVersion\r\n\t\t\t\t\t});\r\n\t\t\t\telse\r\n\t\t\t\t\tonend();\r\n\t\t\t}\r\n\r\n\t\t\texportChild();\r\n\t\t}\r\n\r\n\t\tprocess(zipWriter, entry, onend, onprogress, totalSize);\r\n\t}\r\n\r\n\tfunction addFileEntry(zipEntry, fileEntry, onend, onerror) {\r\n\t\tfunction getChildren(fileEntry, callback) {\r\n\t\t\tif (fileEntry.isDirectory)\r\n\t\t\t\tfileEntry.createReader().readEntries(callback);\r\n\t\t\tif (fileEntry.isFile)\r\n\t\t\t\tcallback([]);\r\n\t\t}\r\n\r\n\t\tfunction process(zipEntry, fileEntry, onend) {\r\n\t\t\tgetChildren(fileEntry, function(children) {\r\n\t\t\t\tvar childIndex = 0;\r\n\r\n\t\t\t\tfunction addChild(child) {\r\n\t\t\t\t\tfunction nextChild(childFileEntry) {\r\n\t\t\t\t\t\tprocess(childFileEntry, child, function() {\r\n\t\t\t\t\t\t\tchildIndex++;\r\n\t\t\t\t\t\t\tprocessChild();\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (child.isDirectory)\r\n\t\t\t\t\t\tnextChild(zipEntry.addDirectory(child.name));\r\n\t\t\t\t\tif (child.isFile)\r\n\t\t\t\t\t\tchild.file(function(file) {\r\n\t\t\t\t\t\t\tvar childZipEntry = zipEntry.addBlob(child.name, file);\r\n\t\t\t\t\t\t\tchildZipEntry.uncompressedSize = file.size;\r\n\t\t\t\t\t\t\tnextChild(childZipEntry);\r\n\t\t\t\t\t\t}, onerror);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction processChild() {\r\n\t\t\t\t\tvar child = children[childIndex];\r\n\t\t\t\t\tif (child)\r\n\t\t\t\t\t\taddChild(child);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tonend();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tprocessChild();\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif (fileEntry.isDirectory)\r\n\t\t\tprocess(zipEntry, fileEntry, onend);\r\n\t\telse\r\n\t\t\tfileEntry.file(function(file) {\r\n\t\t\t\tzipEntry.addBlob(fileEntry.name, file);\r\n\t\t\t\tonend();\r\n\t\t\t}, onerror);\r\n\t}\r\n\r\n\tfunction getFileEntry(fileEntry, entry, onend, onprogress, onerror, totalSize, checkCrc32) {\r\n\t\tvar currentIndex = 0;\r\n\r\n\t\tfunction process(fileEntry, entry, onend, onprogress, onerror, totalSize) {\r\n\t\t\tvar childIndex = 0;\r\n\r\n\t\t\tfunction addChild(child) {\r\n\t\t\t\tfunction nextChild(childFileEntry) {\r\n\t\t\t\t\tcurrentIndex += child.uncompressedSize || 0;\r\n\t\t\t\t\tprocess(childFileEntry, child, function() {\r\n\t\t\t\t\t\tchildIndex++;\r\n\t\t\t\t\t\tprocessChild();\r\n\t\t\t\t\t}, onprogress, onerror, totalSize);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (child.directory)\r\n\t\t\t\t\tfileEntry.getDirectory(child.name, {\r\n\t\t\t\t\t\tcreate : true\r\n\t\t\t\t\t}, nextChild, onerror);\r\n\t\t\t\telse\r\n\t\t\t\t\tfileEntry.getFile(child.name, {\r\n\t\t\t\t\t\tcreate : true\r\n\t\t\t\t\t}, function(file) {\r\n\t\t\t\t\t\tchild.getData(new zip.FileWriter(file, zip.getMimeType(child.name)), nextChild, function(index) {\r\n\t\t\t\t\t\t\tif (onprogress)\r\n\t\t\t\t\t\t\t\tonprogress(currentIndex + index, totalSize);\r\n\t\t\t\t\t\t}, checkCrc32);\r\n\t\t\t\t\t}, onerror);\r\n\t\t\t}\r\n\r\n\t\t\tfunction processChild() {\r\n\t\t\t\tvar child = entry.children[childIndex];\r\n\t\t\t\tif (child)\r\n\t\t\t\t\taddChild(child);\r\n\t\t\t\telse\r\n\t\t\t\t\tonend();\r\n\t\t\t}\r\n\r\n\t\t\tprocessChild();\r\n\t\t}\r\n\r\n\t\tif (entry.directory)\r\n\t\t\tprocess(fileEntry, entry, onend, onprogress, onerror, totalSize);\r\n\t\telse\r\n\t\t\tentry.getData(new zip.FileWriter(fileEntry, zip.getMimeType(entry.name)), onend, onprogress, checkCrc32);\r\n\t}\r\n\r\n\tfunction resetFS(fs) {\r\n\t\tfs.entries = [];\r\n\t\tfs.root = new ZipDirectoryEntry(fs);\r\n\t}\r\n\r\n\tfunction bufferedCopy(reader, writer, onend, onprogress, onerror) {\r\n\t\tvar chunkIndex = 0;\r\n\r\n\t\tfunction stepCopy() {\r\n\t\t\tvar index = chunkIndex * CHUNK_SIZE;\r\n\t\t\tif (onprogress)\r\n\t\t\t\tonprogress(index, reader.size);\r\n\t\t\tif (index < reader.size)\r\n\t\t\t\treader.readUint8Array(index, Math.min(CHUNK_SIZE, reader.size - index), function(array) {\r\n\t\t\t\t\twriter.writeUint8Array(new Uint8Array(array), function() {\r\n\t\t\t\t\t\tchunkIndex++;\r\n\t\t\t\t\t\tstepCopy();\r\n\t\t\t\t\t});\r\n\t\t\t\t}, onerror);\r\n\t\t\telse\r\n\t\t\t\twriter.getData(onend);\r\n\t\t}\r\n\r\n\t\tstepCopy();\r\n\t}\r\n\r\n\tfunction addChild(parent, name, params, directory) {\r\n\t\tif (parent.directory)\r\n\t\t\treturn directory ? new ZipDirectoryEntry(parent.fs, name, params, parent) : new ZipFileEntry(parent.fs, name, params, parent);\r\n\t\telse\r\n\t\t\tthrow \"Parent entry is not a directory.\";\r\n\t}\r\n\r\n\tfunction ZipEntry() {\r\n\t}\r\n\r\n\tZipEntry.prototype = {\r\n\t\tinit : function(fs, name, params, parent) {\r\n\t\t\tvar that = this;\r\n\t\t\tif (fs.root && parent && parent.getChildByName(name))\r\n\t\t\t\tthrow \"Entry filename already exists.\";\r\n\t\t\tif (!params)\r\n\t\t\t\tparams = {};\r\n\t\t\tthat.fs = fs;\r\n\t\t\tthat.name = name;\r\n\t\t\tthat.id = fs.entries.length;\r\n\t\t\tthat.parent = parent;\r\n\t\t\tthat.children = [];\r\n\t\t\tthat.zipVersion = params.zipVersion || 0x14;\r\n\t\t\tthat.uncompressedSize = 0;\r\n\t\t\tfs.entries.push(that);\r\n\t\t\tif (parent)\r\n\t\t\t\tthat.parent.children.push(that);\r\n\t\t},\r\n\t\tgetFileEntry : function(fileEntry, onend, onprogress, onerror, checkCrc32) {\r\n\t\t\tvar that = this;\r\n\t\t\tinitReaders(that, function() {\r\n\t\t\t\tgetFileEntry(fileEntry, that, onend, onprogress, onerror, getTotalSize(that), checkCrc32);\r\n\t\t\t}, onerror);\r\n\t\t},\r\n\t\tmoveTo : function(target) {\r\n\t\t\tvar that = this;\r\n\t\t\tif (target.directory) {\r\n\t\t\t\tif (!target.isDescendantOf(that)) {\r\n\t\t\t\t\tif (that != target) {\r\n\t\t\t\t\t\tif (target.getChildByName(that.name))\r\n\t\t\t\t\t\t\tthrow \"Entry filename already exists.\";\r\n\t\t\t\t\t\tdetach(that);\r\n\t\t\t\t\t\tthat.parent = target;\r\n\t\t\t\t\t\ttarget.children.push(that);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else\r\n\t\t\t\t\tthrow \"Entry is a ancestor of target entry.\";\r\n\t\t\t} else\r\n\t\t\t\tthrow \"Target entry is not a directory.\";\r\n\t\t},\r\n\t\tgetFullname : function() {\r\n\t\t\tvar that = this, fullname = that.name, entry = that.parent;\r\n\t\t\twhile (entry) {\r\n\t\t\t\tfullname = (entry.name ? entry.name + \"/\" : \"\") + fullname;\r\n\t\t\t\tentry = entry.parent;\r\n\t\t\t}\r\n\t\t\treturn fullname;\r\n\t\t},\r\n\t\tisDescendantOf : function(ancestor) {\r\n\t\t\tvar entry = this.parent;\r\n\t\t\twhile (entry && entry.id != ancestor.id)\r\n\t\t\t\tentry = entry.parent;\r\n\t\t\treturn !!entry;\r\n\t\t}\r\n\t};\r\n\tZipEntry.prototype.constructor = ZipEntry;\r\n\r\n\tvar ZipFileEntryProto;\r\n\r\n\tfunction ZipFileEntry(fs, name, params, parent) {\r\n\t\tvar that = this;\r\n\t\tZipEntry.prototype.init.call(that, fs, name, params, parent);\r\n\t\tthat.Reader = params.Reader;\r\n\t\tthat.Writer = params.Writer;\r\n\t\tthat.data = params.data;\r\n\t\tif (params.getData) {\r\n\t\t\tthat.getData = params.getData;\r\n\t\t}\r\n\t}\r\n\r\n\tZipFileEntry.prototype = ZipFileEntryProto = new ZipEntry();\r\n\tZipFileEntryProto.constructor = ZipFileEntry;\r\n\tZipFileEntryProto.getData = function(writer, onend, onprogress, onerror) {\r\n\t\tvar that = this;\r\n\t\tif (!writer || (writer.constructor == that.Writer && that.data))\r\n\t\t\tonend(that.data);\r\n\t\telse {\r\n\t\t\tif (!that.reader)\r\n\t\t\t\tthat.reader = new that.Reader(that.data, onerror);\r\n\t\t\tthat.reader.init(function() {\r\n\t\t\t\twriter.init(function() {\r\n\t\t\t\t\tbufferedCopy(that.reader, writer, onend, onprogress, onerror);\r\n\t\t\t\t}, onerror);\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n\r\n\tZipFileEntryProto.getText = function(onend, onprogress, checkCrc32, encoding) {\r\n\t\tthis.getData(new TextWriter(encoding), onend, onprogress, checkCrc32);\r\n\t};\r\n\tZipFileEntryProto.getBlob = function(mimeType, onend, onprogress, checkCrc32) {\r\n\t\tthis.getData(new BlobWriter(mimeType), onend, onprogress, checkCrc32);\r\n\t};\r\n\tZipFileEntryProto.getData64URI = function(mimeType, onend, onprogress, checkCrc32) {\r\n\t\tthis.getData(new Data64URIWriter(mimeType), onend, onprogress, checkCrc32);\r\n\t};\r\n\r\n\tvar ZipDirectoryEntryProto;\r\n\r\n\tfunction ZipDirectoryEntry(fs, name, params, parent) {\r\n\t\tvar that = this;\r\n\t\tZipEntry.prototype.init.call(that, fs, name, params, parent);\r\n\t\tthat.directory = true;\r\n\t}\r\n\r\n\tZipDirectoryEntry.prototype = ZipDirectoryEntryProto = new ZipEntry();\r\n\tZipDirectoryEntryProto.constructor = ZipDirectoryEntry;\r\n\tZipDirectoryEntryProto.addDirectory = function(name) {\r\n\t\treturn addChild(this, name, null, true);\r\n\t};\r\n\tZipDirectoryEntryProto.addText = function(name, text) {\r\n\t\treturn addChild(this, name, {\r\n\t\t\tdata : text,\r\n\t\t\tReader : TextReader,\r\n\t\t\tWriter : TextWriter\r\n\t\t});\r\n\t};\r\n\tZipDirectoryEntryProto.addBlob = function(name, blob) {\r\n\t\treturn addChild(this, name, {\r\n\t\t\tdata : blob,\r\n\t\t\tReader : BlobReader,\r\n\t\t\tWriter : BlobWriter\r\n\t\t});\r\n\t};\r\n\tZipDirectoryEntryProto.addData64URI = function(name, dataURI) {\r\n\t\treturn addChild(this, name, {\r\n\t\t\tdata : dataURI,\r\n\t\t\tReader : Data64URIReader,\r\n\t\t\tWriter : Data64URIWriter\r\n\t\t});\r\n\t};\r\n\tZipDirectoryEntryProto.addFileEntry = function(fileEntry, onend, onerror) {\r\n\t\taddFileEntry(this, fileEntry, onend, onerror);\r\n\t};\r\n\tZipDirectoryEntryProto.addData = function(name, params) {\r\n\t\treturn addChild(this, name, params);\r\n\t};\r\n\tZipDirectoryEntryProto.importBlob = function(blob, onend, onerror) {\r\n\t\tthis.importZip(new BlobReader(blob), onend, onerror);\r\n\t};\r\n\tZipDirectoryEntryProto.importText = function(text, onend, onerror) {\r\n\t\tthis.importZip(new TextReader(text), onend, onerror);\r\n\t};\r\n\tZipDirectoryEntryProto.importData64URI = function(dataURI, onend, onerror) {\r\n\t\tthis.importZip(new Data64URIReader(dataURI), onend, onerror);\r\n\t};\r\n\tZipDirectoryEntryProto.exportBlob = function(onend, onprogress, onerror) {\r\n\t\tthis.exportZip(new BlobWriter(\"application/zip\"), onend, onprogress, onerror);\r\n\t};\r\n\tZipDirectoryEntryProto.exportText = function(onend, onprogress, onerror) {\r\n\t\tthis.exportZip(new TextWriter(), onend, onprogress, onerror);\r\n\t};\r\n\tZipDirectoryEntryProto.exportFileEntry = function(fileEntry, onend, onprogress, onerror) {\r\n\t\tthis.exportZip(new zip.FileWriter(fileEntry, \"application/zip\"), onend, onprogress, onerror);\r\n\t};\r\n\tZipDirectoryEntryProto.exportData64URI = function(onend, onprogress, onerror) {\r\n\t\tthis.exportZip(new Data64URIWriter(\"application/zip\"), onend, onprogress, onerror);\r\n\t};\r\n\tZipDirectoryEntryProto.importZip = function(reader, onend, onerror) {\r\n\t\tvar that = this;\r\n\t\tcreateReader(reader, function(zipReader) {\r\n\t\t\tzipReader.getEntries(function(entries) {\r\n\t\t\t\tentries.forEach(function(entry) {\r\n\t\t\t\t\tvar parent = that, path = entry.filename.split(\"/\"), name = path.pop();\r\n\t\t\t\t\tpath.forEach(function(pathPart) {\r\n\t\t\t\t\t\tparent = parent.getChildByName(pathPart) || new ZipDirectoryEntry(that.fs, pathPart, null, parent);\r\n\t\t\t\t\t});\r\n\t\t\t\t\tif (!entry.directory)\r\n\t\t\t\t\t\taddChild(parent, name, {\r\n\t\t\t\t\t\t\tdata : entry,\r\n\t\t\t\t\t\t\tReader : ZipBlobReader\r\n\t\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t\tonend();\r\n\t\t\t});\r\n\t\t}, onerror);\r\n\t};\r\n\tZipDirectoryEntryProto.exportZip = function(writer, onend, onprogress, onerror) {\r\n\t\tvar that = this;\r\n\t\tinitReaders(that, function() {\r\n\t\t\tcreateWriter(writer, function(zipWriter) {\r\n\t\t\t\texportZip(zipWriter, that, function() {\r\n\t\t\t\t\tzipWriter.close(onend);\r\n\t\t\t\t}, onprogress, getTotalSize(that));\r\n\t\t\t}, onerror);\r\n\t\t}, onerror);\r\n\t};\r\n\tZipDirectoryEntryProto.getChildByName = function(name) {\r\n\t\tvar childIndex, child, that = this;\r\n\t\tfor (childIndex = 0; childIndex < that.children.length; childIndex++) {\r\n\t\t\tchild = that.children[childIndex];\r\n\t\t\tif (child.name == name)\r\n\t\t\t\treturn child;\r\n\t\t}\r\n\t};\r\n\r\n\tfunction FS() {\r\n\t\tresetFS(this);\r\n\t}\r\n\tFS.prototype = {\r\n\t\tremove : function(entry) {\r\n\t\t\tdetach(entry);\r\n\t\t\tthis.entries[entry.id] = null;\r\n\t\t},\r\n\t\tfind : function(fullname) {\r\n\t\t\tvar index, path = fullname.split(\"/\"), node = this.root;\r\n\t\t\tfor (index = 0; node && index < path.length; index++)\r\n\t\t\t\tnode = node.getChildByName(path[index]);\r\n\t\t\treturn node;\r\n\t\t},\r\n\t\tgetById : function(id) {\r\n\t\t\treturn this.entries[id];\r\n\t\t},\r\n\t\timportBlob : function(blob, onend, onerror) {\r\n\t\t\tresetFS(this);\r\n\t\t\tthis.root.importBlob(blob, onend, onerror);\r\n\t\t},\r\n\t\timportText : function(text, onend, onerror) {\r\n\t\t\tresetFS(this);\r\n\t\t\tthis.root.importText(text, onend, onerror);\r\n\t\t},\r\n\t\timportData64URI : function(dataURI, onend, onerror) {\r\n\t\t\tresetFS(this);\r\n\t\t\tthis.root.importData64URI(dataURI, onend, onerror);\r\n\t\t},\r\n\t\texportBlob : function(onend, onprogress, onerror) {\r\n\t\t\tthis.root.exportBlob(onend, onprogress, onerror);\r\n\t\t},\r\n\t\texportText : function(onend, onprogress, onerror) {\r\n\t\t\tthis.root.exportText(onend, onprogress, onerror);\r\n\t\t},\r\n\t\texportFileEntry : function(fileEntry, onend, onprogress, onerror) {\r\n\t\t\tthis.root.exportFileEntry(fileEntry, onend, onprogress, onerror);\r\n\t\t},\r\n\t\texportData64URI : function(onend, onprogress, onerror) {\r\n\t\t\tthis.root.exportData64URI(onend, onprogress, onerror);\r\n\t\t}\r\n\t};\r\n\r\n\tzip.fs = {\r\n\t\tFS : FS,\r\n\t\tZipDirectoryEntry : ZipDirectoryEntry,\r\n\t\tZipFileEntry : ZipFileEntry\r\n\t};\r\n\r\n\tzip.getMimeType = function() {\r\n\t\treturn \"application/octet-stream\";\r\n\t};\r\n\r\n})();\r\n\ndefine(\"zip-fs\", [\"zip\"], (function (global) {\n    return function () {\n        var ret, fn;\n        return ret || global.zipfs;\n    };\n}(this)));\n\n",
    "/*\r\n Copyright (c) 2013 Gildas Lormeau. All rights reserved.\r\n\r\n Redistribution and use in source and binary forms, with or without\r\n modification, are permitted provided that the following conditions are met:\r\n\r\n 1. Redistributions of source code must retain the above copyright notice,\r\n this list of conditions and the following disclaimer.\r\n\r\n 2. Redistributions in binary form must reproduce the above copyright\r\n notice, this list of conditions and the following disclaimer in\r\n the documentation and/or other materials provided with the distribution.\r\n\r\n 3. The names of the authors may not be used to endorse or promote products\r\n derived from this software without specific prior written permission.\r\n\r\n THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\r\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\r\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\r\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\r\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\r\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\r\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\r\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\r\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n(function() {\r\n\t\"use strict\";\r\n\r\n\tvar ERR_HTTP_RANGE = \"HTTP Range not supported.\";\r\n\r\n\tvar Reader = zip.Reader;\r\n\tvar Writer = zip.Writer;\r\n\t\r\n\tvar ZipDirectoryEntry;\r\n\r\n\tvar appendABViewSupported;\r\n\ttry {\r\n\t\tappendABViewSupported = new Blob([ new DataView(new ArrayBuffer(0)) ]).size === 0;\r\n\t} catch (e) {\r\n\t}\r\n\r\n\tfunction HttpReader(url) {\r\n\t\tvar that = this;\r\n\r\n\t\tfunction getData(callback, onerror) {\r\n\t\t\tvar request;\r\n\t\t\tif (!that.data) {\r\n\t\t\t\trequest = new XMLHttpRequest();\r\n\t\t\t\trequest.addEventListener(\"load\", function() {\r\n\t\t\t\t\tif (!that.size)\r\n\t\t\t\t\t\tthat.size = Number(request.getResponseHeader(\"Content-Length\"));\r\n\t\t\t\t\tthat.data = new Uint8Array(request.response);\r\n\t\t\t\t\tcallback();\r\n\t\t\t\t}, false);\r\n\t\t\t\trequest.addEventListener(\"error\", onerror, false);\r\n\t\t\t\trequest.open(\"GET\", url);\r\n\t\t\t\trequest.responseType = \"arraybuffer\";\r\n\t\t\t\trequest.send();\r\n\t\t\t} else\r\n\t\t\t\tcallback();\r\n\t\t}\r\n\r\n\t\tfunction init(callback, onerror) {\r\n\t\t\tvar request = new XMLHttpRequest();\r\n\t\t\trequest.addEventListener(\"load\", function() {\r\n\t\t\t\tthat.size = Number(request.getResponseHeader(\"Content-Length\"));\r\n\t\t\t\tcallback();\r\n\t\t\t}, false);\r\n\t\t\trequest.addEventListener(\"error\", onerror, false);\r\n\t\t\trequest.open(\"HEAD\", url);\r\n\t\t\trequest.send();\r\n\t\t}\r\n\r\n\t\tfunction readUint8Array(index, length, callback, onerror) {\r\n\t\t\tgetData(function() {\r\n\t\t\t\tcallback(new Uint8Array(that.data.subarray(index, index + length)));\r\n\t\t\t}, onerror);\r\n\t\t}\r\n\r\n\t\tthat.size = 0;\r\n\t\tthat.init = init;\r\n\t\tthat.readUint8Array = readUint8Array;\r\n\t}\r\n\tHttpReader.prototype = new Reader();\r\n\tHttpReader.prototype.constructor = HttpReader;\r\n\r\n\tfunction HttpRangeReader(url) {\r\n\t\tvar that = this;\r\n\r\n\t\tfunction init(callback, onerror) {\r\n\t\t\tvar request = new XMLHttpRequest();\r\n\t\t\trequest.addEventListener(\"load\", function() {\r\n\t\t\t\tthat.size = Number(request.getResponseHeader(\"Content-Length\"));\r\n\t\t\t\tif (request.getResponseHeader(\"Accept-Ranges\") == \"bytes\")\r\n\t\t\t\t\tcallback();\r\n\t\t\t\telse\r\n\t\t\t\t\tonerror(ERR_HTTP_RANGE);\r\n\t\t\t}, false);\r\n\t\t\trequest.addEventListener(\"error\", onerror, false);\r\n\t\t\trequest.open(\"HEAD\", url);\r\n\t\t\trequest.send();\r\n\t\t}\r\n\r\n\t\tfunction readArrayBuffer(index, length, callback, onerror) {\r\n\t\t\tvar request = new XMLHttpRequest();\r\n\t\t\trequest.open(\"GET\", url);\r\n\t\t\trequest.responseType = \"arraybuffer\";\r\n\t\t\trequest.setRequestHeader(\"Range\", \"bytes=\" + index + \"-\" + (index + length - 1));\r\n\t\t\trequest.addEventListener(\"load\", function() {\r\n\t\t\t\tcallback(request.response);\r\n\t\t\t}, false);\r\n\t\t\trequest.addEventListener(\"error\", onerror, false);\r\n\t\t\trequest.send();\r\n\t\t}\r\n\r\n\t\tfunction readUint8Array(index, length, callback, onerror) {\r\n\t\t\treadArrayBuffer(index, length, function(arraybuffer) {\r\n\t\t\t\tcallback(new Uint8Array(arraybuffer));\r\n\t\t\t}, onerror);\r\n\t\t}\r\n\r\n\t\tthat.size = 0;\r\n\t\tthat.init = init;\r\n\t\tthat.readUint8Array = readUint8Array;\r\n\t}\r\n\tHttpRangeReader.prototype = new Reader();\r\n\tHttpRangeReader.prototype.constructor = HttpRangeReader;\r\n\r\n\tfunction ArrayBufferReader(arrayBuffer) {\r\n\t\tvar that = this;\r\n\r\n\t\tfunction init(callback, onerror) {\r\n\t\t\tthat.size = arrayBuffer.byteLength;\r\n\t\t\tcallback();\r\n\t\t}\r\n\r\n\t\tfunction readUint8Array(index, length, callback, onerror) {\r\n\t\t\tcallback(new Uint8Array(arrayBuffer.slice(index, index + length)));\r\n\t\t}\r\n\r\n\t\tthat.size = 0;\r\n\t\tthat.init = init;\r\n\t\tthat.readUint8Array = readUint8Array;\r\n\t}\r\n\tArrayBufferReader.prototype = new Reader();\r\n\tArrayBufferReader.prototype.constructor = ArrayBufferReader;\r\n\r\n\tfunction ArrayBufferWriter() {\r\n\t\tvar array, that = this;\r\n\r\n\t\tfunction init(callback, onerror) {\r\n\t\t\tarray = new Uint8Array();\r\n\t\t\tcallback();\r\n\t\t}\r\n\r\n\t\tfunction writeUint8Array(arr, callback, onerror) {\r\n\t\t\tvar tmpArray = new Uint8Array(array.length + arr.length);\r\n\t\t\ttmpArray.set(array);\r\n\t\t\ttmpArray.set(arr, array.length);\r\n\t\t\tarray = tmpArray;\r\n\t\t\tcallback();\r\n\t\t}\r\n\r\n\t\tfunction getData(callback) {\r\n\t\t\tcallback(array.buffer);\r\n\t\t}\r\n\r\n\t\tthat.init = init;\r\n\t\tthat.writeUint8Array = writeUint8Array;\r\n\t\tthat.getData = getData;\r\n\t}\r\n\tArrayBufferWriter.prototype = new Writer();\r\n\tArrayBufferWriter.prototype.constructor = ArrayBufferWriter;\r\n\r\n\tfunction FileWriter(fileEntry, contentType) {\r\n\t\tvar writer, that = this;\r\n\r\n\t\tfunction init(callback, onerror) {\r\n\t\t\tfileEntry.createWriter(function(fileWriter) {\r\n\t\t\t\twriter = fileWriter;\r\n\t\t\t\tcallback();\r\n\t\t\t}, onerror);\r\n\t\t}\r\n\r\n\t\tfunction writeUint8Array(array, callback, onerror) {\r\n\t\t\tvar blob = new Blob([ appendABViewSupported ? array : array.buffer ], {\r\n\t\t\t\ttype : contentType\r\n\t\t\t});\r\n\t\t\twriter.onwrite = function() {\r\n\t\t\t\twriter.onwrite = null;\r\n\t\t\t\tcallback();\r\n\t\t\t};\r\n\t\t\twriter.onerror = onerror;\r\n\t\t\twriter.write(blob);\r\n\t\t}\r\n\r\n\t\tfunction getData(callback) {\r\n\t\t\tfileEntry.file(callback);\r\n\t\t}\r\n\r\n\t\tthat.init = init;\r\n\t\tthat.writeUint8Array = writeUint8Array;\r\n\t\tthat.getData = getData;\r\n\t}\r\n\tFileWriter.prototype = new Writer();\r\n\tFileWriter.prototype.constructor = FileWriter;\r\n\r\n\tzip.FileWriter = FileWriter;\r\n\tzip.HttpReader = HttpReader;\r\n\tzip.HttpRangeReader = HttpRangeReader;\r\n\tzip.ArrayBufferReader = ArrayBufferReader;\r\n\tzip.ArrayBufferWriter = ArrayBufferWriter;\r\n\r\n\tif (zip.fs) {\r\n\t\tZipDirectoryEntry = zip.fs.ZipDirectoryEntry;\r\n\t\tZipDirectoryEntry.prototype.addHttpContent = function(name, URL, useRangeHeader) {\r\n\t\t\tfunction addChild(parent, name, params, directory) {\r\n\t\t\t\tif (parent.directory)\r\n\t\t\t\t\treturn directory ? new ZipDirectoryEntry(parent.fs, name, params, parent) : new zip.fs.ZipFileEntry(parent.fs, name, params, parent);\r\n\t\t\t\telse\r\n\t\t\t\t\tthrow \"Parent entry is not a directory.\";\r\n\t\t\t}\r\n\r\n\t\t\treturn addChild(this, name, {\r\n\t\t\t\tdata : URL,\r\n\t\t\t\tReader : useRangeHeader ? HttpRangeReader : HttpReader\r\n\t\t\t});\r\n\t\t};\r\n\t\tZipDirectoryEntry.prototype.importHttpContent = function(URL, useRangeHeader, onend, onerror) {\r\n\t\t\tthis.importZip(useRangeHeader ? new HttpRangeReader(URL) : new HttpReader(URL), onend, onerror);\r\n\t\t};\r\n\t\tzip.fs.FS.prototype.importHttpContent = function(URL, useRangeHeader, onend, onerror) {\r\n\t\t\tthis.entries = [];\r\n\t\t\tthis.root = new ZipDirectoryEntry(this);\r\n\t\t\tthis.root.importHttpContent(URL, useRangeHeader, onend, onerror);\r\n\t\t};\r\n\t}\r\n\r\n})();\r\n\ndefine(\"zip-ext\", [\"zip-fs\"], (function (global) {\n    return function () {\n        var ret, fn;\n        return ret || global.zipext;\n    };\n}(this)));\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\ndefine('epub-fetch/zip_resource_fetcher',['jquery', 'URIjs', './discover_content_type', 'zip-ext'], function ($, URI, ContentTypeDiscovery, zip) {\r\n\r\n    var ZipResourceFetcher = function(parentFetcher, baseUrl, libDir) {\r\n\r\n        var _checkCrc32 = false;\r\n        var _zipFs;\r\n\r\n        // INTERNAL FUNCTIONS\r\n\r\n        // Description: perform a function with an initialized zip filesystem, making sure that such filesystem is initialized.\r\n        // Note that due to a race condition, more than one zip filesystem may be instantiated.\r\n        // However, the last one to be set on the model object will prevail and others would be garbage collected later.\r\n        function withZipFsPerform(callback, onerror) {\r\n\r\n            if (_zipFs) {\r\n\r\n                callback(_zipFs, onerror);\r\n\r\n            } else {\r\n\r\n                // The Web Worker requires standalone inflate/deflate.js files in libDir (i.e. cannot be aggregated/minified/optimised in the final generated single-file build)\r\n                zip.useWebWorkers = true; // (true by default)\r\n                zip.workerScriptsPath = libDir;\r\n                \r\n                _zipFs = new zip.fs.FS();\r\n                _zipFs.importHttpContent(baseUrl, true, function () {\r\n\r\n                    callback(_zipFs, onerror);\r\n\r\n                }, onerror)\r\n            }\r\n        }\r\n\r\n        function fetchFileContents (relativePathRelativeToPackageRoot, readCallback, onerror) {\r\n\r\n            if (typeof relativePathRelativeToPackageRoot === 'undefined') {\r\n                throw 'Fetched file relative path is undefined!';\r\n            }\r\n\r\n            withZipFsPerform(function (zipFs, onerror) {\r\n                var entry = zipFs.find(relativePathRelativeToPackageRoot);\r\n                if (typeof entry === 'undefined' || entry === null) {\r\n                    onerror(new Error('Entry ' + relativePathRelativeToPackageRoot + ' not found in zip ' + baseUrl));\r\n                } else {\r\n                    if (entry.directory) {\r\n                        onerror(new Error('Entry ' + relativePathRelativeToPackageRoot + ' is a directory while a file has been expected'));\r\n                    } else {\r\n                        readCallback(entry);\r\n                    }\r\n                }\r\n            }, onerror);\r\n        }\r\n\r\n\r\n        // PUBLIC API\r\n\r\n        this.getPackageUrl = function() {\r\n            return baseUrl;\r\n        };\r\n\r\n        this.fetchFileContentsText = function(relativePathRelativeToPackageRoot, fetchCallback, onerror) {\r\n\r\n            fetchFileContents(relativePathRelativeToPackageRoot, function (entry) {\r\n                entry.getText(fetchCallback, undefined, _checkCrc32);\r\n            }, onerror)\r\n        };\r\n\r\n        this.fetchFileContentsData64Uri = function(relativePathRelativeToPackageRoot, fetchCallback, onerror) {\r\n            fetchFileContents(relativePathRelativeToPackageRoot, function (entry) {\r\n                entry.getData64URI(ContentTypeDiscovery.identifyContentTypeFromFileName(relativePathRelativeToPackageRoot),\r\n                    fetchCallback, undefined, _checkCrc32);\r\n            }, onerror)\r\n        };\r\n\r\n        this.fetchFileContentsBlob = function(relativePathRelativeToPackageRoot, fetchCallback, onerror) {\r\n            var decryptionFunction = parentFetcher.getDecryptionFunctionForRelativePath(relativePathRelativeToPackageRoot);\r\n            if (decryptionFunction) {\r\n                var origFetchCallback = fetchCallback;\r\n                fetchCallback = function (unencryptedBlob) {\r\n                    decryptionFunction(unencryptedBlob, function (decryptedBlob) {\r\n                        origFetchCallback(decryptedBlob);\r\n                    });\r\n                };\r\n            }\r\n            fetchFileContents(relativePathRelativeToPackageRoot, function (entry) {\r\n                entry.getBlob(ContentTypeDiscovery.identifyContentTypeFromFileName(relativePathRelativeToPackageRoot), fetchCallback,\r\n                    undefined, _checkCrc32);\r\n            }, onerror)\r\n        };\r\n\r\n    };\r\n\r\n    return ZipResourceFetcher;\r\n});\r\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\ndefine(\r\n    'epub-fetch/content_document_fetcher',['jquery', 'underscore', 'URIjs', './discover_content_type'],\r\n    function ($, _, URI, ContentTypeDiscovery) {\r\n\r\n\r\n        var ContentDocumentFetcher = function (publicationFetcher, spineItem, loadedDocumentUri, publicationResourcesCache, contentDocumentTextPreprocessor) {\r\n\r\n            var self = this;\r\n\r\n            var _contentDocumentPathRelativeToPackage = spineItem.href;\r\n            var _publicationFetcher = publicationFetcher;\r\n            var _contentDocumentText;\r\n            var _srcMediaType = spineItem.media_type;\r\n            var _contentDocumentDom;\r\n            var _publicationResourcesCache = publicationResourcesCache;\r\n            var _contentDocumentTextPreprocessor = contentDocumentTextPreprocessor;\r\n\r\n            // PUBLIC API\r\n\r\n            this.fetchContentDocumentAndResolveDom = function (contentDocumentResolvedCallback, errorCallback) {\r\n                _publicationFetcher.relativeToPackageFetchFileContents(_contentDocumentPathRelativeToPackage, 'text',\r\n                    function (contentDocumentText) {\r\n                        _contentDocumentText = contentDocumentText;\r\n                        if (_contentDocumentTextPreprocessor) {\r\n                            _contentDocumentText = _contentDocumentTextPreprocessor(loadedDocumentUri, _contentDocumentText);\r\n                        }\r\n                        self.resolveInternalPackageResources(contentDocumentResolvedCallback, errorCallback);\r\n                    }, errorCallback\r\n                );\r\n            };\r\n\r\n            this.resolveInternalPackageResources = function (resolvedDocumentCallback, onerror) {\r\n\r\n                _contentDocumentDom = _publicationFetcher.markupParser.parseMarkup(_contentDocumentText, _srcMediaType);\r\n                setBaseUri(_contentDocumentDom, loadedDocumentUri);\r\n\r\n                var resolutionDeferreds = [];\r\n\r\n                if (_publicationFetcher.shouldFetchMediaAssetsProgrammatically()) {\r\n                    resolveDocumentImages(resolutionDeferreds, onerror);\r\n                    resolveDocumentAudios(resolutionDeferreds, onerror);\r\n                    resolveDocumentVideos(resolutionDeferreds, onerror);\r\n                }\r\n                // TODO: recursive fetching, parsing and DOM construction of documents in IFRAMEs,\r\n                // with CSS preprocessing and obfuscated font handling\r\n                resolveDocumentIframes(resolutionDeferreds, onerror);\r\n                // TODO: resolution (e.g. using DOM mutation events) of scripts loaded dynamically by scripts\r\n                resolveDocumentScripts(resolutionDeferreds, onerror);\r\n                resolveDocumentLinkStylesheets(resolutionDeferreds, onerror);\r\n                resolveDocumentEmbeddedStylesheets(resolutionDeferreds, onerror);\r\n\r\n                $.when.apply($, resolutionDeferreds).done(function () {\r\n                    resolvedDocumentCallback(_contentDocumentDom);\r\n                });\r\n\r\n            };\r\n\r\n            // INTERNAL FUNCTIONS\r\n\r\n            function setBaseUri(documentDom, baseURI) {\r\n                var baseElem = documentDom.getElementsByTagName('base')[0];\r\n                if (!baseElem) {\r\n                    baseElem = documentDom.createElement('base');\r\n\r\n                    var anchor = documentDom.getElementsByTagName('head')[0];\r\n                    if (anchor) {\r\n                        anchor.insertBefore(baseElem, anchor.childNodes[0]);\r\n                    }\r\n                }\r\n                baseElem.setAttribute('href', baseURI);\r\n            }\r\n\r\n            function _handleError(err) {\r\n                if (err) {\r\n                    if (err.message) {\r\n                        console.error(err.message);\r\n                    }\r\n                    if (err.stack) {\r\n                        console.error(err.stack);\r\n                    }\r\n                }\r\n                console.error(err);\r\n            }\r\n\r\n            function fetchResourceForElement(resolvedElem, refAttrOrigVal, refAttr, fetchMode, resolutionDeferreds,\r\n                                             onerror, resourceDataPreprocessing) {\r\n                var resourceUriRelativeToPackageDocument = (new URI(refAttrOrigVal)).absoluteTo(_contentDocumentPathRelativeToPackage).toString();\r\n\r\n                var cachedResourceUrl = _publicationResourcesCache.getResourceURL(resourceUriRelativeToPackageDocument);\r\n\r\n                function replaceRefAttrInElem(newResourceUrl) {\r\n                    // Store original refAttrVal in a special attribute to provide access to the original href:\r\n                    $(resolvedElem).data('epubZipOrigHref', refAttrOrigVal);\r\n                    $(resolvedElem).attr(refAttr, newResourceUrl);\r\n                }\r\n\r\n                if (cachedResourceUrl) {\r\n                    replaceRefAttrInElem(cachedResourceUrl);\r\n                } else {\r\n                    var resolutionDeferred = $.Deferred();\r\n                    resolutionDeferreds.push(resolutionDeferred);\r\n\r\n                    _publicationFetcher.relativeToPackageFetchFileContents(resourceUriRelativeToPackageDocument,\r\n                        fetchMode,\r\n                        function (resourceData) {\r\n\r\n                            // Generate a function to replace element's resource URL with URL of fetched data.\r\n                            // The function will either be called directly, immediately (if no preprocessing of resourceData is in effect)\r\n                            // or indirectly, later after resourceData preprocessing finishes:\r\n                            var replaceResourceURL = function (finalResourceData) {\r\n                                // Creating an object URL requires a Blob object, so resource data fetched in text mode needs to be wrapped in a Blob:\r\n                                if (fetchMode === 'text') {\r\n                                    var textResourceContentType = ContentTypeDiscovery.identifyContentTypeFromFileName(resourceUriRelativeToPackageDocument);\r\n                                    var declaredType = $(resolvedElem).attr('type');\r\n                                    if (declaredType) {\r\n                                        textResourceContentType = declaredType;\r\n                                    }\r\n                                    finalResourceData = new Blob([finalResourceData], {type: textResourceContentType});\r\n                                }\r\n                                //noinspection JSUnresolvedVariable,JSUnresolvedFunction\r\n                                var resourceObjectURL = window.URL.createObjectURL(finalResourceData);\r\n                                _publicationResourcesCache.putResource(resourceUriRelativeToPackageDocument,\r\n                                    resourceObjectURL, finalResourceData);\r\n                                // TODO: take care of releasing object URLs when no longer needed\r\n                                replaceRefAttrInElem(resourceObjectURL);\r\n                                resolutionDeferred.resolve();\r\n                            };\r\n\r\n                            if (resourceDataPreprocessing) {\r\n                                resourceDataPreprocessing(resourceData, resourceUriRelativeToPackageDocument,\r\n                                    replaceResourceURL);\r\n                            } else {\r\n                                replaceResourceURL(resourceData);\r\n                            }\r\n                        }, onerror);\r\n                }\r\n            }\r\n\r\n            function fetchResourceForCssUrlMatch(cssUrlMatch, cssResourceDownloadDeferreds,\r\n                                                 styleSheetUriRelativeToPackageDocument, stylesheetCssResourceUrlsMap,\r\n                                                 isStyleSheetResource) {\r\n                var origMatchedUrlString = cssUrlMatch[0];\r\n\r\n                var extractedUrlCandidates = cssUrlMatch.slice(2);\r\n                var extractedUrl = _.find(extractedUrlCandidates, function(matchGroup){ return typeof matchGroup !== 'undefined' });\r\n\r\n                var extractedUri = new URI(extractedUrl);\r\n                var isCssUrlRelative = extractedUri.scheme() === '';\r\n                if (!isCssUrlRelative) {\r\n                    // Absolute URLs don't need programmatic fetching\r\n                    return;\r\n                }\r\n                var resourceUriRelativeToPackageDocument = (new URI(extractedUrl)).absoluteTo(styleSheetUriRelativeToPackageDocument).toString();\r\n\r\n                var cachedResourceURL = _publicationResourcesCache.getResourceURL(resourceUriRelativeToPackageDocument);\r\n\r\n\r\n                if (cachedResourceURL) {\r\n                    stylesheetCssResourceUrlsMap[origMatchedUrlString] = {\r\n                        isStyleSheetResource: isStyleSheetResource,\r\n                        resourceObjectURL: cachedResourceURL\r\n                    };\r\n                } else {\r\n                    var cssUrlFetchDeferred = $.Deferred();\r\n                    cssResourceDownloadDeferreds.push(cssUrlFetchDeferred);\r\n\r\n                    var processedBlobCallback = function (resourceDataBlob) {\r\n                        //noinspection JSUnresolvedVariable,JSUnresolvedFunction\r\n                        var resourceObjectURL = window.URL.createObjectURL(resourceDataBlob);\r\n                        stylesheetCssResourceUrlsMap[origMatchedUrlString] = {\r\n                            isStyleSheetResource: isStyleSheetResource,\r\n                            resourceObjectURL: resourceObjectURL\r\n                        };\r\n                        _publicationResourcesCache.putResource(resourceUriRelativeToPackageDocument,\r\n                            resourceObjectURL, resourceDataBlob);\r\n                        cssUrlFetchDeferred.resolve();\r\n                    };\r\n                    var fetchErrorCallback = function (error) {\r\n                        _handleError(error);\r\n                        cssUrlFetchDeferred.resolve();\r\n                    };\r\n\r\n                    var fetchMode;\r\n                    var fetchCallback;\r\n                    if (isStyleSheetResource) {\r\n                        // TODO: test whether recursion works for nested @import rules with arbitrary indirection depth.\r\n                        fetchMode = 'text';\r\n                        fetchCallback = function (styleSheetResourceData) {\r\n                            preprocessCssStyleSheetData(styleSheetResourceData, resourceUriRelativeToPackageDocument,\r\n                                function (preprocessedStyleSheetData) {\r\n                                    var resourceDataBlob = new Blob([preprocessedStyleSheetData], {type: 'text/css'});\r\n                                    processedBlobCallback(resourceDataBlob);\r\n                                })\r\n                        }\r\n                    } else {\r\n                        fetchMode = 'blob';\r\n                        fetchCallback = processedBlobCallback;\r\n                    }\r\n\r\n                    _publicationFetcher.relativeToPackageFetchFileContents(resourceUriRelativeToPackageDocument,\r\n                        fetchMode,\r\n                        fetchCallback, fetchErrorCallback);\r\n                }\r\n            }\r\n\r\n            function preprocessCssStyleSheetData(styleSheetResourceData, styleSheetUriRelativeToPackageDocument,\r\n                                                 callback) {\r\n                var cssUrlRegexp = /[Uu][Rr][Ll]\\(\\s*([']([^']+)[']|[\"]([^\"]+)[\"]|([^)]+))\\s*\\)/g;\r\n                var nonUrlCssImportRegexp = /@[Ii][Mm][Pp][Oo][Rr][Tt]\\s*('([^']+)'|\"([^\"]+)\")/g;\r\n                var stylesheetCssResourceUrlsMap = {};\r\n                var cssResourceDownloadDeferreds = [];\r\n                // Go through the stylesheet text using all regexps and process according to those regexp matches, if any:\r\n                [nonUrlCssImportRegexp, cssUrlRegexp].forEach(function (processingRegexp) {\r\n                    // extract all URL references in the CSS sheet,\r\n                    var cssUrlMatch = processingRegexp.exec(styleSheetResourceData);\r\n                    while (cssUrlMatch != null) {\r\n                        // then fetch and replace them with corresponding object URLs:\r\n                        var isStyleSheetResource = false;\r\n                        // Special handling of @import-ed stylesheet files - recursive preprocessing:\r\n                        // TODO: will not properly handle @import url(...):\r\n                        if (processingRegexp == nonUrlCssImportRegexp) {\r\n                            // This resource URL points to an @import-ed CSS stylesheet file. Need to preprocess its text\r\n                            // after fetching but before making an object URL of it:\r\n                            isStyleSheetResource = true;\r\n                        }\r\n                        fetchResourceForCssUrlMatch(cssUrlMatch, cssResourceDownloadDeferreds,\r\n                            styleSheetUriRelativeToPackageDocument, stylesheetCssResourceUrlsMap, isStyleSheetResource);\r\n                        cssUrlMatch = processingRegexp.exec(styleSheetResourceData);\r\n                    }\r\n\r\n                });\r\n\r\n                if (cssResourceDownloadDeferreds.length > 0) {\r\n                    $.when.apply($, cssResourceDownloadDeferreds).done(function () {\r\n                        for (var origMatchedUrlString in stylesheetCssResourceUrlsMap) {\r\n                            var processedResourceDescriptor = stylesheetCssResourceUrlsMap[origMatchedUrlString];\r\n\r\n\r\n                            var processedUrlString;\r\n                            if (processedResourceDescriptor.isStyleSheetResource) {\r\n                                processedUrlString = '@import \"' + processedResourceDescriptor.resourceObjectURL + '\"';\r\n                            } else {\r\n                                processedUrlString = \"url('\" + processedResourceDescriptor.resourceObjectURL + \"')\";\r\n                            }\r\n                            var origMatchedUrlStringEscaped = origMatchedUrlString.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g,\r\n                                \"\\\\$&\");\r\n                            var origMatchedUrlStringRegExp = new RegExp(origMatchedUrlStringEscaped, 'g');\r\n                            //noinspection JSCheckFunctionSignatures\r\n                            styleSheetResourceData =\r\n                                styleSheetResourceData.replace(origMatchedUrlStringRegExp, processedUrlString, 'g');\r\n\r\n                        }\r\n                        callback(styleSheetResourceData);\r\n                    });\r\n                } else {\r\n                    callback(styleSheetResourceData);\r\n                }\r\n            }\r\n\r\n\r\n            function resolveResourceElements(elemName, refAttr, fetchMode, resolutionDeferreds, onerror,\r\n                                             resourceDataPreprocessing) {\r\n\r\n                var resolvedElems = $(elemName + '[' + refAttr.replace(':', '\\\\:') + ']', _contentDocumentDom);\r\n\r\n                resolvedElems.each(function (index, resolvedElem) {\r\n                    var refAttrOrigVal = $(resolvedElem).attr(refAttr);\r\n                    var refAttrUri = new URI(refAttrOrigVal);\r\n\r\n                    if (refAttrUri.scheme() === '') {\r\n                        // Relative URI, fetch from packed EPUB archive:\r\n\r\n                        fetchResourceForElement(resolvedElem, refAttrOrigVal, refAttr, fetchMode, resolutionDeferreds,\r\n                            onerror, resourceDataPreprocessing);\r\n                    }\r\n                });\r\n            }\r\n\r\n            function resolveDocumentImages(resolutionDeferreds, onerror) {\r\n                resolveResourceElements('img', 'src', 'blob', resolutionDeferreds, onerror);\r\n                resolveResourceElements('image', 'xlink:href', 'blob', resolutionDeferreds, onerror);\r\n            }\r\n\r\n            function resolveDocumentAudios(resolutionDeferreds, onerror) {\r\n                resolveResourceElements('audio', 'src', 'blob', resolutionDeferreds, onerror);\r\n            }\r\n\r\n            function resolveDocumentVideos(resolutionDeferreds, onerror) {\r\n                resolveResourceElements('video', 'src', 'blob', resolutionDeferreds, onerror);\r\n                resolveResourceElements('video', 'poster', 'blob', resolutionDeferreds, onerror);\r\n            }\r\n\r\n            function resolveDocumentScripts(resolutionDeferreds, onerror) {\r\n                resolveResourceElements('script', 'src', 'blob', resolutionDeferreds, onerror);\r\n            }\r\n\r\n            function resolveDocumentIframes(resolutionDeferreds, onerror) {\r\n                resolveResourceElements('iframe', 'src', 'blob', resolutionDeferreds, onerror);\r\n            }\r\n\r\n            function resolveDocumentLinkStylesheets(resolutionDeferreds, onerror) {\r\n                resolveResourceElements('link', 'href', 'text', resolutionDeferreds, onerror,\r\n                    preprocessCssStyleSheetData);\r\n            }\r\n\r\n            function resolveDocumentEmbeddedStylesheets(resolutionDeferreds, onerror) {\r\n                var resolvedElems = $('style', _contentDocumentDom);\r\n                resolvedElems.each(function (index, resolvedElem) {\r\n                    var resolutionDeferred = $.Deferred();\r\n                    resolutionDeferreds.push(resolutionDeferred);\r\n                    var styleSheetData = $(resolvedElem).text();\r\n                    preprocessCssStyleSheetData(styleSheetData, _contentDocumentPathRelativeToPackage,\r\n                        function (resolvedStylesheetData) {\r\n                            $(resolvedElem).text(resolvedStylesheetData);\r\n                            resolutionDeferred.resolve();\r\n                        });\r\n                });\r\n            }\r\n\r\n        };\r\n\r\n        return ContentDocumentFetcher;\r\n\r\n    }\r\n);\r\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\ndefine('epub-fetch/resource_cache',['underscore'], function (_) {\r\n\r\n        var ResourceCache = function(sourceWindow, configuredCacheSizeEvictThreshold) {\r\n\r\n            var self = this;\r\n            var _resourcesHash = {};\r\n            var _orderingByLastUseTimestamp = [];\r\n            var _cacheSize = 0;\r\n            var CACHE_SIZE_EVICT_THRESHOLD_DEFAULT = 100000000;\r\n            var cacheSizeEvictThreshold = determineCacheSizeThreshold();\r\n\r\n            function getTimestamp() {\r\n                return new Date().getTime();\r\n            }\r\n\r\n            function getBrowserHeapLimitInBytes() {\r\n                if (window.performance && window.performance.memory && window.performance.memory.jsHeapSizeLimit) {\r\n                    return window.performance.memory.jsHeapSizeLimit;\r\n                } else {\r\n                    return null;\r\n                }\r\n            }\r\n\r\n            function determineCacheSizeThreshold() {\r\n                if (configuredCacheSizeEvictThreshold) {\r\n                    return configuredCacheSizeEvictThreshold;\r\n                }\r\n                var browserHeapLimitInBytes = getBrowserHeapLimitInBytes();\r\n                if (browserHeapLimitInBytes && browserHeapLimitInBytes / 10 > CACHE_SIZE_EVICT_THRESHOLD_DEFAULT) {\r\n                    return browserHeapLimitInBytes / 10;\r\n                } else {\r\n                    return  CACHE_SIZE_EVICT_THRESHOLD_DEFAULT;\r\n                }\r\n            }\r\n\r\n            this.getResourceURL = function(resourceAbsoluteHref) {\r\n                var resourceObjectUrl = null;\r\n                var resourceData = _resourcesHash[resourceAbsoluteHref];\r\n                if (resourceData) {\r\n                    resourceObjectUrl = resourceData.url;\r\n                    resourceData.lastUseTimestamp = getTimestamp();\r\n                    updateOrderedIndex(resourceData);\r\n                }\r\n                return resourceObjectUrl;\r\n            };\r\n\r\n            function removeCacheEntryFromOrderedIndex(cacheEntry) {\r\n                // Remove the previous entry from the ordered index, if present:\r\n                if (typeof cacheEntry.orderingByLastUseTimestampIdx !== 'undefined') {\r\n                    var orderingByLastUseTimestampIdx = cacheEntry.orderingByLastUseTimestampIdx;\r\n                    _orderingByLastUseTimestamp.splice(orderingByLastUseTimestampIdx, 1);\r\n                    // Decrement index values for all downshifted entries:\r\n                    for (var i = orderingByLastUseTimestampIdx; i < _orderingByLastUseTimestamp.length; i++) {\r\n                        var downshiftedEntry = _orderingByLastUseTimestamp[i];\r\n                        // Assertion\r\n                        if ((downshiftedEntry.orderingByLastUseTimestampIdx - 1) != i) {\r\n                            console.error('algorithm incorrect: downshiftedEntry.orderingByLastUseTimestampIdx: ' +\r\n                                downshiftedEntry.orderingByLastUseTimestampIdx + ', i: ' + i);\r\n                        }\r\n                        downshiftedEntry.orderingByLastUseTimestampIdx = i;\r\n                    }\r\n                }\r\n            }\r\n\r\n            function updateOrderedIndex(cacheEntry) {\r\n                removeCacheEntryFromOrderedIndex(cacheEntry);\r\n                var insertIdx = _.sortedIndex(_orderingByLastUseTimestamp, cacheEntry, 'lastUseTimestamp');\r\n                _orderingByLastUseTimestamp.splice(insertIdx, 0, cacheEntry);\r\n                cacheEntry.orderingByLastUseTimestampIdx = insertIdx;\r\n            }\r\n\r\n            this.putResource = function(resourceAbsoluteHref, resourceObjectUrl, resourceDataBlob) {\r\n                this.trimCache();\r\n                var currentTimestamp = getTimestamp();\r\n                var cacheEntry = {\r\n                    url: resourceObjectUrl,\r\n                    absoluteHref: resourceAbsoluteHref,\r\n                    blob: resourceDataBlob,\r\n                    blobSize: resourceDataBlob.size,\r\n                    creationTimestamp: currentTimestamp,\r\n                    lastUseTimestamp: currentTimestamp,\r\n                    pinned: true\r\n                };\r\n                _resourcesHash[resourceAbsoluteHref] = cacheEntry;\r\n                updateOrderedIndex(cacheEntry);\r\n                _cacheSize += resourceDataBlob.size;\r\n            };\r\n\r\n            this.evictResource = function(resourceAbsoluteHref) {\r\n                var resourceData = _resourcesHash[resourceAbsoluteHref];\r\n                if (resourceData) {\r\n                    sourceWindow.URL.revokeObjectURL(resourceData.url);\r\n                    _cacheSize -= resourceData.blobSize;\r\n                    removeCacheEntryFromOrderedIndex(resourceData);\r\n                    delete _resourcesHash[resourceAbsoluteHref];\r\n                }\r\n            };\r\n\r\n            this.flushCache = function() {\r\n                // TODO: more efficient, but less code reuse: iterate over _sortedIndex first,\r\n                // then assert an empty cache and perform backup cleanup if assertion failed\r\n                for (var resourceAbsoluteHref in _resourcesHash) {\r\n                    this.evictResource(resourceAbsoluteHref);\r\n                }\r\n                // Assertion\r\n                if (_cacheSize != 0) {\r\n                    console.error('cacheSize accounting error! cacheSize: ' + _cacheSize + ', _resourcesHash:');\r\n                    console.error(_resourcesHash);\r\n                }\r\n                _orderingByLastUseTimestamp = [];\r\n                //console.log('Cache contents:');\r\n                //console.log(_resourcesHash);\r\n                //console.log('_orderingByLastUseTimestamp:');\r\n                //console.log(_orderingByLastUseTimestamp);\r\n                //console.log('Cache size:' + _cacheSize);\r\n            };\r\n\r\n            this.unPinResources = function() {\r\n                for (var resourceAbsoluteHref in _resourcesHash) {\r\n                    var resourceData = _resourcesHash[resourceAbsoluteHref];\r\n                    resourceData.pinned = false;\r\n                }\r\n            };\r\n\r\n            function orderingByLastUseTimestampToString() {\r\n                return _orderingByLastUseTimestamp.reduce(function(previousValue, currentValue) {\r\n                    return previousValue + (previousValue.length > 1 ? ', ' : '') + '[' +\r\n                        currentValue.absoluteHref + ', pinned: ' + currentValue.pinned +\r\n                        ', orderingByLastUseTimestampIdx: ' + currentValue.orderingByLastUseTimestampIdx + ']'\r\n                }, '');\r\n            }\r\n\r\n            this.trimCache = function() {\r\n                if (_cacheSize < cacheSizeEvictThreshold) {\r\n                    return;\r\n                }\r\n                console.log('Trimming cache. Current cache size: ' + _cacheSize);\r\n\r\n                // Loop through ordered index (by last use timestamp) starting from the least recently used entries.\r\n                // evict unpinned resources until either:\r\n                // 1) cache size drops below CACHE_SIZE_EVICT_THRESHOLD\r\n                // 2) there are no more unpinned resources to evict\r\n                for (var i = 0; i < _orderingByLastUseTimestamp.length; i++) {\r\n                    if (_cacheSize < cacheSizeEvictThreshold) {\r\n                        break;\r\n                    }\r\n                    var cacheEntry = _orderingByLastUseTimestamp[i];\r\n                    if (!cacheEntry.pinned) {\r\n                        var resourceAbsoluteHref = cacheEntry.absoluteHref;\r\n                        //console.log('Preparing to evict ' + resourceAbsoluteHref);\r\n                        //console.log('_orderingByLastUseTimestamp:');\r\n                        //console.log(orderingByLastUseTimestampToString());\r\n                        this.evictResource(resourceAbsoluteHref);\r\n                        //console.log('Evicted ' + resourceAbsoluteHref);\r\n                        //console.log('Current cache size: ' + _cacheSize);\r\n                        //console.log('_orderingByLastUseTimestamp:');\r\n                        //console.log(orderingByLastUseTimestampToString());\r\n                        //console.log('i: ' + i);\r\n\r\n                        // The consequent array elements have downshifted by one position.\r\n                        // The i variable now points to a different element - the evicted element's successor\r\n                        // (if not beyond array's end).\r\n                        // Make the i variable remain in place - compensate for its upcoming incrementation:\r\n                        i--;\r\n                    }\r\n                }\r\n                console.log('Cache size after trimming: ' + _cacheSize);\r\n            };\r\n        };\r\n\r\n        return ResourceCache;\r\n    });\r\n\n",
    "(function(e,r){\"object\"==typeof exports?module.exports=exports=r():\"function\"==typeof define&&define.amd?define('cryptoJs/core',[],r):e.CryptoJS=r()})(this,function(){var e=e||function(e,r){var t={},i=t.lib={},n=i.Base=function(){function e(){}return{extend:function(r){e.prototype=this;var t=new e;return r&&t.mixIn(r),t.hasOwnProperty(\"init\")||(t.init=function(){t.$super.init.apply(this,arguments)}),t.init.prototype=t,t.$super=this,t},create:function(){var e=this.extend();return e.init.apply(e,arguments),e},init:function(){},mixIn:function(e){for(var r in e)e.hasOwnProperty(r)&&(this[r]=e[r]);e.hasOwnProperty(\"toString\")&&(this.toString=e.toString)},clone:function(){return this.init.prototype.extend(this)}}}(),o=i.WordArray=n.extend({init:function(e,t){e=this.words=e||[],this.sigBytes=t!=r?t:4*e.length},toString:function(e){return(e||s).stringify(this)},concat:function(e){var r=this.words,t=e.words,i=this.sigBytes,n=e.sigBytes;if(this.clamp(),i%4)for(var o=0;n>o;o++){var c=255&t[o>>>2]>>>24-8*(o%4);r[i+o>>>2]|=c<<24-8*((i+o)%4)}else if(t.length>65535)for(var o=0;n>o;o+=4)r[i+o>>>2]=t[o>>>2];else r.push.apply(r,t);return this.sigBytes+=n,this},clamp:function(){var r=this.words,t=this.sigBytes;r[t>>>2]&=4294967295<<32-8*(t%4),r.length=e.ceil(t/4)},clone:function(){var e=n.clone.call(this);return e.words=this.words.slice(0),e},random:function(r){for(var t=[],i=0;r>i;i+=4)t.push(0|4294967296*e.random());return new o.init(t,r)}}),c=t.enc={},s=c.Hex={stringify:function(e){for(var r=e.words,t=e.sigBytes,i=[],n=0;t>n;n++){var o=255&r[n>>>2]>>>24-8*(n%4);i.push((o>>>4).toString(16)),i.push((15&o).toString(16))}return i.join(\"\")},parse:function(e){for(var r=e.length,t=[],i=0;r>i;i+=2)t[i>>>3]|=parseInt(e.substr(i,2),16)<<24-4*(i%8);return new o.init(t,r/2)}},u=c.Latin1={stringify:function(e){for(var r=e.words,t=e.sigBytes,i=[],n=0;t>n;n++){var o=255&r[n>>>2]>>>24-8*(n%4);i.push(String.fromCharCode(o))}return i.join(\"\")},parse:function(e){for(var r=e.length,t=[],i=0;r>i;i++)t[i>>>2]|=(255&e.charCodeAt(i))<<24-8*(i%4);return new o.init(t,r)}},f=c.Utf8={stringify:function(e){try{return decodeURIComponent(escape(u.stringify(e)))}catch(r){throw Error(\"Malformed UTF-8 data\")}},parse:function(e){return u.parse(unescape(encodeURIComponent(e)))}},a=i.BufferedBlockAlgorithm=n.extend({reset:function(){this._data=new o.init,this._nDataBytes=0},_append:function(e){\"string\"==typeof e&&(e=f.parse(e)),this._data.concat(e),this._nDataBytes+=e.sigBytes},_process:function(r){var t=this._data,i=t.words,n=t.sigBytes,c=this.blockSize,s=4*c,u=n/s;u=r?e.ceil(u):e.max((0|u)-this._minBufferSize,0);var f=u*c,a=e.min(4*f,n);if(f){for(var p=0;f>p;p+=c)this._doProcessBlock(i,p);var d=i.splice(0,f);t.sigBytes-=a}return new o.init(d,a)},clone:function(){var e=n.clone.call(this);return e._data=this._data.clone(),e},_minBufferSize:0});i.Hasher=a.extend({cfg:n.extend(),init:function(e){this.cfg=this.cfg.extend(e),this.reset()},reset:function(){a.reset.call(this),this._doReset()},update:function(e){return this._append(e),this._process(),this},finalize:function(e){e&&this._append(e);var r=this._doFinalize();return r},blockSize:16,_createHelper:function(e){return function(r,t){return new e.init(t).finalize(r)}},_createHmacHelper:function(e){return function(r,t){return new p.HMAC.init(e,t).finalize(r)}}});var p=t.algo={};return t}(Math);return e});\ndefine('cryptoJs', ['cryptoJs/core'], function (main) { return main; });\n\n",
    "(function(e,r){\"object\"==typeof exports?module.exports=exports=r(require(\"./core\")):\"function\"==typeof define&&define.amd?define('cryptoJs/sha1',[\"./core\"],r):r(e.CryptoJS)})(this,function(e){return function(){var r=e,t=r.lib,n=t.WordArray,i=t.Hasher,o=r.algo,s=[],c=o.SHA1=i.extend({_doReset:function(){this._hash=new n.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(e,r){for(var t=this._hash.words,n=t[0],i=t[1],o=t[2],c=t[3],a=t[4],f=0;80>f;f++){if(16>f)s[f]=0|e[r+f];else{var u=s[f-3]^s[f-8]^s[f-14]^s[f-16];s[f]=u<<1|u>>>31}var d=(n<<5|n>>>27)+a+s[f];d+=20>f?(i&o|~i&c)+1518500249:40>f?(i^o^c)+1859775393:60>f?(i&o|i&c|o&c)-1894007588:(i^o^c)-899497514,a=c,c=o,o=i<<30|i>>>2,i=n,n=d}t[0]=0|t[0]+n,t[1]=0|t[1]+i,t[2]=0|t[2]+o,t[3]=0|t[3]+c,t[4]=0|t[4]+a},_doFinalize:function(){var e=this._data,r=e.words,t=8*this._nDataBytes,n=8*e.sigBytes;return r[n>>>5]|=128<<24-n%32,r[(n+64>>>9<<4)+14]=Math.floor(t/4294967296),r[(n+64>>>9<<4)+15]=t,e.sigBytes=4*r.length,this._process(),this._hash},clone:function(){var e=i.clone.call(this);return e._hash=this._hash.clone(),e}});r.SHA1=i._createHelper(c),r.HmacSHA1=i._createHmacHelper(c)}(),e.SHA1});\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\ndefine('epub-fetch/encryption_handler',['cryptoJs/sha1'], function (SHA1) {\r\n\r\n    var EncryptionHandler = function (encryptionData) {\r\n        var self = this;\r\n\r\n        var ENCRYPTION_METHODS = {\r\n            'http://www.idpf.org/2008/embedding': embeddedFontDeobfuscateIdpf,\r\n            'http://ns.adobe.com/pdf/enc#RC': embeddedFontDeobfuscateAdobe\r\n        };\r\n\r\n        // INTERNAL FUNCTIONS\r\n\r\n        function blob2BinArray(blob, callback) {\r\n            var fileReader = new FileReader();\r\n            fileReader.onload = function () {\r\n                var arrayBuffer = this.result;\r\n                callback(new Uint8Array(arrayBuffer));\r\n            };\r\n            fileReader.readAsArrayBuffer(blob);\r\n        }\r\n\r\n        function xorObfuscatedBlob(obfuscatedResourceBlob, prefixLength, xorKey, callback) {\r\n            var obfuscatedPrefixBlob = obfuscatedResourceBlob.slice(0, prefixLength);\r\n            blob2BinArray(obfuscatedPrefixBlob, function (bytes) {\r\n                var masklen = xorKey.length;\r\n                for (var i = 0; i < prefixLength; i++) {\r\n                    bytes[i] = bytes[i] ^ (xorKey[i % masklen]);\r\n                }\r\n                var deobfuscatedPrefixBlob = new Blob([bytes], { type: obfuscatedResourceBlob.type });\r\n                var remainderBlob = obfuscatedResourceBlob.slice(prefixLength);\r\n                var deobfuscatedBlob = new Blob([deobfuscatedPrefixBlob, remainderBlob],\r\n                    { type: obfuscatedResourceBlob.type });\r\n\r\n                callback(deobfuscatedBlob);\r\n            });\r\n        }\r\n\r\n        function embeddedFontDeobfuscateIdpf(obfuscatedResourceBlob, callback) {\r\n\r\n            var prefixLength = 1040;\r\n            // Shamelessly copied from\r\n            // https://github.com/readium/readium-chrome-extension/blob/26d4b0cafd254cfa93bf7f6225887b83052642e0/scripts/models/path_resolver.js#L102 :\r\n            xorObfuscatedBlob(obfuscatedResourceBlob, prefixLength, encryptionData.uidHash, callback);\r\n        }\r\n\r\n        function urnUuidToByteArray(id) {\r\n            var uuidRegexp = /(urn:uuid:)?([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})/i;\r\n            var matchResults = uuidRegexp.exec(id);\r\n            var rawUuid = matchResults[2] + matchResults[3] + matchResults[4] + matchResults[5] + matchResults[6];\r\n            if (!rawUuid || rawUuid.length != 32) {\r\n                console.error('Bad UUID format for ID :' + id);\r\n            }\r\n            var byteArray = [];\r\n            for (var i = 0; i < 16; i++) {\r\n                var byteHex = rawUuid.substr(i * 2, 2);\r\n                var byteNumber = parseInt(byteHex, 16);\r\n                byteArray.push(byteNumber);\r\n            }\r\n            return byteArray;\r\n        }\r\n\r\n        function embeddedFontDeobfuscateAdobe(obfuscatedResourceBlob, callback) {\r\n\r\n            // extract the UUID and convert to big-endian binary form (16 bytes):\r\n            var uidWordArray = urnUuidToByteArray(encryptionData.uid);\r\n            var prefixLength = 1024;\r\n            xorObfuscatedBlob(obfuscatedResourceBlob, prefixLength, uidWordArray, callback)\r\n        }\r\n\r\n\r\n        // PUBLIC API\r\n\r\n        this.isEncryptionSpecified = function () {\r\n            return encryptionData && encryptionData.encryptions;\r\n        };\r\n\r\n\r\n        this.getEncryptionMethodForRelativePath = function (pathRelativeToRoot) {\r\n            if (self.isEncryptionSpecified()) {\r\n                return encryptionData.encryptions[pathRelativeToRoot];\r\n            } else {\r\n                return undefined;\r\n            }\r\n        };\r\n\r\n        this.getDecryptionFunctionForRelativePath = function (pathRelativeToRoot) {\r\n            var encryptionMethod = self.getEncryptionMethodForRelativePath(pathRelativeToRoot);\r\n            if (encryptionMethod && ENCRYPTION_METHODS[encryptionMethod]) {\r\n                return ENCRYPTION_METHODS[encryptionMethod];\r\n            } else {\r\n                return undefined;\r\n            }\r\n        };\r\n\r\n    };\r\n\r\n    EncryptionHandler.CreateEncryptionData =  function(id, encryptionDom) {\r\n\r\n        var encryptionData = {\r\n            uid: id,\r\n            uidHash: SHA1(unescape(encodeURIComponent(id.trim())), { asBytes: true }),\r\n            encryptions: undefined\r\n        };\r\n\r\n        var encryptedData = $('EncryptedData', encryptionDom);\r\n        encryptedData.each(function (index, encryptedData) {\r\n            var encryptionAlgorithm = $('EncryptionMethod', encryptedData).first().attr('Algorithm');\r\n\r\n            // For some reason, jQuery selector \"\" against XML DOM sometimes doesn't match properly\r\n            var cipherReference = $('CipherReference', encryptedData);\r\n            cipherReference.each(function (index, CipherReference) {\r\n                var cipherReferenceURI = $(CipherReference).attr('URI');\r\n                console.log('Encryption/obfuscation algorithm ' + encryptionAlgorithm + ' specified for ' +\r\n                    cipherReferenceURI);\r\n\r\n                if(!encryptionData.encryptions) {\r\n                    encryptionData.encryptions = {};\r\n                }\r\n\r\n                encryptionData.encryptions[cipherReferenceURI] = encryptionAlgorithm;\r\n            });\r\n        });\r\n\r\n        return encryptionData;\r\n    };\r\n\r\n    return EncryptionHandler;\r\n});\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\ndefine('epub-fetch/publication_fetcher',['jquery', 'URIjs', './markup_parser', './plain_resource_fetcher', './zip_resource_fetcher',\r\n    './content_document_fetcher', './resource_cache', './encryption_handler'],\r\n    function ($, URI, MarkupParser, PlainResourceFetcher, ZipResourceFetcher, ContentDocumentFetcher,\r\n              ResourceCache, EncryptionHandler) {\r\n\r\n    var PublicationFetcher = function(bookRoot, jsLibRoot, sourceWindow, cacheSizeEvictThreshold, contentDocumentTextPreprocessor) {\r\n\r\n        var self = this;\r\n\r\n        self.contentTypePackageReadStrategyMap = {\r\n            'application/oebps-package+xml': 'exploded',\r\n            'application/epub+zip': 'zipped',\r\n            'application/zip': 'zipped'\r\n        };\r\n\r\n        var _shouldConstructDomProgrammatically;\r\n        var _resourceFetcher;\r\n        var _encryptionHandler;\r\n        var _packageFullPath;\r\n        var _packageDom;\r\n        var _packageDomInitializationDeferred;\r\n        var _publicationResourcesCache = new ResourceCache(sourceWindow, cacheSizeEvictThreshold);\r\n\r\n        var _contentDocumentTextPreprocessor = contentDocumentTextPreprocessor;\r\n\r\n        this.markupParser = new MarkupParser();\r\n\r\n        this.initialize =  function(callback) {\r\n\r\n            var isEpubExploded = isExploded();\r\n\r\n            // Non exploded EPUBs (i.e. zipped .epub documents) should be fetched in a programmatical manner:\r\n            _shouldConstructDomProgrammatically = !isEpubExploded;\r\n            createResourceFetcher(isEpubExploded, callback);\r\n        };\r\n\r\n\r\n\r\n        // INTERNAL FUNCTIONS\r\n\r\n        function _handleError(err) {\r\n            if (err) {\r\n                if (err.message) {\r\n                    console.error(err.message);\r\n                }\r\n                if (err.stack) {\r\n                    console.error(err.stack);\r\n                }\r\n            }\r\n            console.error(err);\r\n        }\r\n\r\n        function isExploded() {\r\n\r\n            var ext = \".epub\";\r\n            return bookRoot.indexOf(ext, bookRoot.length - ext.length) === -1;\r\n        }\r\n\r\n        function createResourceFetcher(isExploded, callback) {\r\n            if (isExploded) {\r\n                console.log('using new PlainResourceFetcher');\r\n                _resourceFetcher = new PlainResourceFetcher(self, bookRoot);\r\n                _resourceFetcher.initialize(function () {\r\n                    callback(_resourceFetcher);\r\n                });\r\n                return;\r\n            } else {\r\n                console.log('using new ZipResourceFetcher');\r\n                _resourceFetcher = new ZipResourceFetcher(self, bookRoot, jsLibRoot);\r\n                callback(_resourceFetcher);\r\n            }\r\n        }\r\n\r\n        // PUBLIC API\r\n\r\n        /**\r\n         * Determine whether the documents fetched using this fetcher require special programmatic handling.\r\n         * (resolving of internal resource references).\r\n         * @returns {*} true if documents fetched using this fetcher require special programmatic handling\r\n         * (resolving of internal resource references). Typically needed for zipped EPUBs or exploded EPUBs that contain\r\n         * encrypted resources specified in META-INF/encryption.xml.\r\n         *\r\n         * false if documents can be fed directly into a window or iframe by src URL without using special fetching logic.\r\n         */\r\n        this.shouldConstructDomProgrammatically = function (){\r\n            return _shouldConstructDomProgrammatically;\r\n        };\r\n\r\n        /**\r\n         * Determine whether the media assets (audio, video, images) within content documents require special\r\n         * programmatic handling.\r\n         * @returns {*} true if content documents fetched using this fetcher require programmatic fetching\r\n         * of media assets. Typically needed for zipped EPUBs.\r\n         *\r\n         * false if paths to media assets are accessible directly for the browser through their paths relative to\r\n         * the base URI of their content document.\r\n         */\r\n        this.shouldFetchMediaAssetsProgrammatically = function() {\r\n            return _shouldConstructDomProgrammatically && !isExploded();\r\n        };\r\n\r\n        this.getBookRoot = function() {\r\n            return bookRoot;\r\n        };\r\n\r\n        this.getJsLibRoot = function() {\r\n            return jsLibRoot;\r\n        };\r\n\r\n        this.flushCache = function() {\r\n            _publicationResourcesCache.flushCache();\r\n        };\r\n\r\n        this.getPackageUrl = function() {\r\n            return _resourceFetcher.getPackageUrl();\r\n        };\r\n\r\n        this.fetchContentDocument = function (attachedData, loadedDocumentUri, contentDocumentResolvedCallback, errorCallback) {\r\n\r\n            // Resources loaded for previously fetched document no longer need to be pinned:\r\n            _publicationResourcesCache.unPinResources();\r\n            var contentDocumentFetcher = new ContentDocumentFetcher(self, attachedData.spineItem, loadedDocumentUri, _publicationResourcesCache, _contentDocumentTextPreprocessor);\r\n            contentDocumentFetcher.fetchContentDocumentAndResolveDom(contentDocumentResolvedCallback, function (err) {\r\n                _handleError(err);\r\n                errorCallback(err);\r\n            });\r\n        };\r\n\r\n        this.getFileContentsFromPackage = function(filePathRelativeToPackageRoot, callback, onerror) {\r\n\r\n            _resourceFetcher.fetchFileContentsText(filePathRelativeToPackageRoot, function (fileContents) {\r\n                callback(fileContents);\r\n            }, onerror);\r\n        };\r\n\r\n\r\n\r\n        this.getXmlFileDom = function (xmlFilePathRelativeToPackageRoot, callback, onerror) {\r\n            self.getFileContentsFromPackage(xmlFilePathRelativeToPackageRoot, function (xmlFileContents) {\r\n                var fileDom = self.markupParser.parseXml(xmlFileContents);\r\n                callback(fileDom);\r\n            }, onerror);\r\n        };\r\n\r\n        this.getPackageFullPath = function(callback, onerror) {\r\n            self.getXmlFileDom('META-INF/container.xml', function (containerXmlDom) {\r\n                var packageFullPath = self.getRootFile(containerXmlDom);\r\n                callback(packageFullPath);\r\n            }, onerror);\r\n        };\r\n\r\n        this.getRootFile = function(containerXmlDom) {\r\n            var rootFile = $('rootfile', containerXmlDom);\r\n            var packageFullPath = rootFile.attr('full-path');\r\n            return packageFullPath;\r\n        };\r\n\r\n        this.getPackageDom = function (callback, onerror) {\r\n            if (_packageDom) {\r\n                callback(_packageDom);\r\n            } else {\r\n                // TODO: use jQuery's Deferred\r\n                // Register all callbacks interested in initialized packageDom, launch its instantiation only once\r\n                // and broadcast to all callbacks registered during the initialization once it's done:\r\n                if (_packageDomInitializationDeferred) {\r\n                    _packageDomInitializationDeferred.done(callback);\r\n                } else {\r\n                    _packageDomInitializationDeferred = $.Deferred();\r\n                    _packageDomInitializationDeferred.done(callback);\r\n                    self.getPackageFullPath(function (packageFullPath) {\r\n                        _packageFullPath = packageFullPath;\r\n                        self.getXmlFileDom(packageFullPath, function (packageDom) {\r\n                            _packageDom = packageDom;\r\n                            _packageDomInitializationDeferred.resolve(packageDom);\r\n                            _packageDomInitializationDeferred = undefined;\r\n                        })\r\n                    }, onerror);\r\n                }\r\n            }\r\n        };\r\n\r\n        this.convertPathRelativeToPackageToRelativeToBase = function (relativeToPackagePath) {\r\n            return new URI(relativeToPackagePath).absoluteTo(_packageFullPath).toString();\r\n        };\r\n\r\n        this.relativeToPackageFetchFileContents = function(relativeToPackagePath, fetchMode, fetchCallback, onerror) {\r\n\r\n            if (! onerror) {\r\n                onerror = _handleError;\r\n            }\r\n\r\n            var pathRelativeToEpubRoot = decodeURIComponent(self.convertPathRelativeToPackageToRelativeToBase(relativeToPackagePath));\r\n            // In case we received an absolute path, convert it to relative form or the fetch will fail:\r\n            if (pathRelativeToEpubRoot.charAt(0) === '/') {\r\n                pathRelativeToEpubRoot = pathRelativeToEpubRoot.substr(1);\r\n            }\r\n            var fetchFunction = _resourceFetcher.fetchFileContentsText;\r\n            if (fetchMode === 'blob') {\r\n                fetchFunction = _resourceFetcher.fetchFileContentsBlob;\r\n            } else if (fetchMode === 'data64uri') {\r\n                fetchFunction = _resourceFetcher.fetchFileContentsData64Uri;\r\n            }\r\n            fetchFunction.call(_resourceFetcher, pathRelativeToEpubRoot, fetchCallback, onerror);\r\n        };\r\n\r\n\r\n\r\n        this.getRelativeXmlFileDom = function (filePath, callback, errorCallback) {\r\n            self.getXmlFileDom(self.convertPathRelativeToPackageToRelativeToBase(filePath), callback, errorCallback);\r\n        };\r\n\r\n        function readEncriptionData(callback) {\r\n            self.getXmlFileDom('META-INF/encryption.xml', function (encryptionDom, error) {\r\n\r\n                if(error) {\r\n                    console.log(error);\r\n                    console.log(\"Document doesn't make use of encryption.\");\r\n                    _encryptionHandler = new EncryptionHandler(undefined);\r\n                    callback();\r\n                }\r\n                else {\r\n\r\n                    var encryptions = [];\r\n\r\n\r\n                    var encryptedData = $('EncryptedData', encryptionDom);\r\n                    encryptedData.each(function (index, encryptedData) {\r\n                        var encryptionAlgorithm = $('EncryptionMethod', encryptedData).first().attr('Algorithm');\r\n\r\n                        encryptions.push({algorithm: encryptionAlgorithm});\r\n\r\n                        // For some reason, jQuery selector \"\" against XML DOM sometimes doesn't match properly\r\n                        var cipherReference = $('CipherReference', encryptedData);\r\n                        cipherReference.each(function (index, CipherReference) {\r\n                            var cipherReferenceURI = $(CipherReference).attr('URI');\r\n                            console.log('Encryption/obfuscation algorithm ' + encryptionAlgorithm + ' specified for ' +\r\n                                cipherReferenceURI);\r\n                            encryptions[cipherReferenceURI] = encryptionAlgorithm;\r\n                        });\r\n                    });\r\n                }\r\n\r\n            });\r\n        }\r\n\r\n        // Currently needed for deobfuscating fonts\r\n        this.setPackageMetadata = function(packageMetadata, settingFinishedCallback) {\r\n\r\n            self.getXmlFileDom('META-INF/encryption.xml', function (encryptionDom) {\r\n\r\n                var encryptionData = EncryptionHandler.CreateEncryptionData(packageMetadata.id, encryptionDom);\r\n\r\n                _encryptionHandler = new EncryptionHandler(encryptionData);\r\n\r\n                if (_encryptionHandler.isEncryptionSpecified()) {\r\n                    // EPUBs that use encryption for any resources should be fetched in a programmatical manner:\r\n                    _shouldConstructDomProgrammatically = true;\r\n                }\r\n\r\n                settingFinishedCallback();\r\n\r\n\r\n            }, function(error){\r\n\r\n                console.log(\"Document doesn't make use of encryption.\");\r\n                _encryptionHandler = new EncryptionHandler(undefined);\r\n\r\n                settingFinishedCallback();\r\n            });\r\n        };\r\n\r\n        this.getDecryptionFunctionForRelativePath = function(pathRelativeToRoot) {\r\n            return _encryptionHandler.getDecryptionFunctionForRelativePath(pathRelativeToRoot);\r\n        }\r\n    };\r\n\r\n    return PublicationFetcher\r\n\r\n});\r\n\ndefine('epub-fetch', ['epub-fetch/publication_fetcher'], function (main) { return main; });\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\ndefine('epub-model/package_document',['jquery', 'underscore', 'URIjs'],\r\n    function ($, _, URI) {\r\n\r\n    // Description: This model provides an interface for navigating an EPUB's package document\r\n    var PackageDocument = function(packageDocumentURL, resourceFetcher, metadata, spine, manifest) {\r\n\r\n        var _page_prog_dir;\r\n\r\n        this.manifest = manifest;\r\n\r\n        this.getSharedJsPackageData = function () {\r\n\r\n            var packageDocRoot = packageDocumentURL.substr(0, packageDocumentURL.lastIndexOf(\"/\"));\r\n            return {\r\n                rootUrl : packageDocRoot,\r\n                rendition_viewport : metadata.rendition_viewport,\r\n                rendition_layout : metadata.rendition_layout,\r\n                rendition_orientation : metadata.rendition_orientation,\r\n                rendition_flow : metadata.rendition_flow,\r\n                rendition_spread : metadata.rendition_spread,\r\n                media_overlay : metadata.media_overlay,\r\n                spine : {\r\n                    direction : this.getPageProgressionDirection(),\r\n                    items : spine\r\n                }\r\n            };\r\n        };\r\n\r\n        /**\r\n         * Get spine item data in readium-shared-js accepted format.\r\n         * @param spineIndex the index of the item within the spine\r\n         * @returns Spine item data in readium-shared-js accepted format.\r\n         */\r\n        this.getSpineItem = function(spineIndex) {\r\n            var spineItem = spine[spineIndex];\r\n            return spineItem;\r\n        };\r\n\r\n        this.setPageProgressionDirection = function(page_prog_dir) {\r\n            _page_prog_dir = page_prog_dir;\r\n        };\r\n\r\n\r\n        this.getPageProgressionDirection = function() {\r\n            if (_page_prog_dir === \"rtl\") {\r\n                return \"rtl\";\r\n            }\r\n            else if (_page_prog_dir === \"default\") {\r\n                return \"default\";\r\n            }\r\n            else {\r\n                return \"ltr\";\r\n            }\r\n        };\r\n\r\n        this.spineLength = function() {\r\n            return spine.length;\r\n        };\r\n\r\n        this.getMetadata = function() {\r\n            return metadata;\r\n        };\r\n\r\n        this.getToc = function() {\r\n            var item = getTocItem();\r\n            if (item) {\r\n                return item.href;\r\n            }\r\n            return null;\r\n        };\r\n\r\n        this.getTocText = function(callback) {\r\n            var toc = this.getToc();\r\n\r\n            resourceFetcher.relativeToPackageFetchFileContents(toc, 'text', function (tocDocumentText) {\r\n                callback(tocDocumentText)\r\n            }, function (err) {\r\n                console.error('ERROR fetching TOC from [' + toc + ']:');\r\n                console.error(err);\r\n                callback(undefined);\r\n            });\r\n        };\r\n\r\n        this.getTocDom = function(callback) {\r\n\r\n            this.getTocText(function (tocText) {\r\n                if (typeof tocText === 'string') {\r\n                    var tocDom = (new DOMParser()).parseFromString(tocText, \"text/xml\");\r\n                    callback(tocDom);\r\n                } else {\r\n                    callback(undefined);\r\n                }\r\n            });\r\n        };\r\n\r\n\r\n        // Used in EpubReader (readium-js-viewer)\r\n        // https://github.com/readium/readium-js-viewer/blob/develop/lib/EpubReader.js#L59\r\n        this.generateTocListDOM = function(callback) {\r\n            var that = this;\r\n            this.getTocDom(function (tocDom) {\r\n                if (tocDom) {\r\n                    if (tocIsNcx()) {\r\n                        var $ncxOrderedList;\r\n                        $ncxOrderedList = getNcxOrderedList($(\"navMap\", tocDom));\r\n                        callback($ncxOrderedList[0]);\r\n                    } else {\r\n                        var packageDocumentAbsoluteURL = new URI(packageDocumentURL).absoluteTo(document.URL);\r\n                        var tocDocumentAbsoluteURL = new URI(that.getToc()).absoluteTo(packageDocumentAbsoluteURL);\r\n                        // add a BASE tag to change the TOC document's baseURI.\r\n                        var oldBaseTag = $(tocDom).remove('base');\r\n                        var newBaseTag = $('<base></base>');\r\n                        $(newBaseTag).attr('href', tocDocumentAbsoluteURL);\r\n                        $(tocDom).find('head').append(newBaseTag);\r\n                        // TODO: fix TOC hrefs both for exploded in zipped EPUBs\r\n                        callback(tocDom);\r\n                    }\r\n                } else {\r\n                    callback(undefined);\r\n                }\r\n            });\r\n        };\r\n\r\n        function tocIsNcx() {\r\n\r\n            var tocItem = getTocItem();\r\n            var contentDocURI = tocItem.href;\r\n            var fileExtension = contentDocURI.substr(contentDocURI.lastIndexOf('.') + 1);\r\n\r\n            return fileExtension.trim().toLowerCase() === \"ncx\";\r\n        }\r\n\r\n        // ----------------------- PRIVATE HELPERS -------------------------------- //\r\n\r\n        function getNcxOrderedList($navMapDOM) {\r\n\r\n            var $ol = $(\"<ol></ol>\");\r\n            $.each($navMapDOM.children(\"navPoint\"), function (index, navPoint) {\r\n                addNavPointElements($(navPoint), $ol);\r\n            });\r\n            return $ol;\r\n        }\r\n\r\n        // Description: Constructs an html representation of NCX navPoints, based on an object of navPoint information\r\n        // Rationale: This is a recursive method, as NCX navPoint elements can nest 0 or more of themselves as children\r\n        function addNavPointElements($navPointDOM, $ol) {\r\n\r\n            // Add the current navPoint element to the TOC html\r\n            var navText = $navPointDOM.children(\"navLabel\").text().trim();\r\n            var navHref = $navPointDOM.children(\"content\").attr(\"src\");\r\n            var $navPointLi = $('<li class=\"nav-elem\"></li>').append(\r\n                $('<a></a>', { href: navHref, text: navText })\r\n            );\r\n\r\n            // Append nav point info\r\n            $ol.append($navPointLi);\r\n\r\n            // Append ordered list of nav points\r\n            if ($navPointDOM.children(\"navPoint\").length > 0 ) {\r\n\r\n                var $newLi = $(\"<li></li>\");\r\n                var $newOl = $(\"<ol></ol>\");\r\n                $.each($navPointDOM.children(\"navPoint\"), function (navIndex, navPoint) {\r\n                    $newOl.append(addNavPointElements($(navPoint), $newOl));\r\n                });\r\n\r\n                $newLi.append($newOl);\r\n                $ol.append($newLi);\r\n            }\r\n        }\r\n\r\n        function getTocItem(){\r\n\r\n            var item = manifest.getNavItem();\r\n            if (item) {\r\n                return item;\r\n            }\r\n\r\n            var spine_id = metadata.ncx;\r\n            if (spine_id && spine_id.length > 0) {\r\n                return manifest.getManifestItemByIdref(spine_id);\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n    };\r\n\r\n    return PackageDocument;\r\n});\r\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\ndefine('epub-model/smil_document_parser',['jquery', 'underscore'], function ($, _) {\r\n\r\n    // `SmilDocumentParser` is used to parse the xml of an epub package\r\n    // document and build a javascript object. The constructor accepts an\r\n    // instance of `URI` that is used to resolve paths during the process\r\n    var SmilDocumentParser = function(packageDocument, publicationFetcher) {\r\n\r\n        // Parse a media overlay manifest item XML\r\n        this.parse = function(spineItem, manifestItemSMIL, smilJson, deferred, callback, errorCallback) {\r\n            var that = this;\r\n            publicationFetcher.getRelativeXmlFileDom(manifestItemSMIL.href, function(xmlDom) {\r\n\r\n                var smil = $(\"smil\", xmlDom)[0];\r\n                smilJson.smilVersion = smil.getAttribute('version');\r\n\r\n                //var body = $(\"body\", xmlDom)[0];\r\n                smilJson.children = that.getChildren(smil);\r\n                smilJson.href = manifestItemSMIL.href;\r\n                smilJson.id = manifestItemSMIL.id;\r\n                smilJson.spineItemId = spineItem.idref;\r\n\r\n                var mediaItem = packageDocument.getMetadata().getMediaItemByRefinesId(manifestItemSMIL.id);\r\n                if (mediaItem) {\r\n                    smilJson.duration = mediaItem.duration;\r\n                }\r\n\r\n                callback(deferred, smilJson);\r\n            }, function(fetchError) {\r\n                errorCallback(deferred, fetchError);\r\n            });\r\n        };\r\n\r\n        var safeCopyProperty = function(property, fromNode, toItem, isRequired, defaultValue) {\r\n            var propParse = property.split(':');\r\n            var destProperty = propParse[propParse.length - 1];\r\n\r\n            if (destProperty === \"type\") {\r\n                destProperty = \"epubtype\";\r\n            }\r\n            \r\n            if (fromNode.getAttribute(property) != undefined) {\r\n                toItem[destProperty] = fromNode.getAttribute(property);\r\n            } else if (isRequired) {\r\n                if (defaultValue !== undefined) {\r\n                    toItem[destProperty] = defaultValue;\r\n                } else {\r\n                    console.log(\"Required property \" + property + \" not found in smil node \" + fromNode.nodeName);\r\n                }\r\n            }\r\n        };\r\n\r\n        this.getChildren = function(element) {\r\n            var that = this;\r\n            var children = [];\r\n\r\n            $.each(element.childNodes, function(elementIndex, currElement) {\r\n\r\n                if (currElement.nodeType === 1) { // ELEMENT\r\n                    var item = that.createItemFromElement(currElement);\r\n                    if (item) {\r\n                        children.push(item);\r\n                    }\r\n                }\r\n            });\r\n\r\n            return children;\r\n        }\r\n\r\n        this.createItemFromElement = function(element) {\r\n            var that = this;\r\n\r\n            var item = {};\r\n            item.nodeType = element.nodeName;\r\n            \r\n            var isBody = false;\r\n            if (item.nodeType === \"body\")\r\n            {\r\n                isBody = true;\r\n                item.nodeType = \"seq\";\r\n            }\r\n\r\n            if (item.nodeType === \"seq\") {\r\n\r\n                safeCopyProperty(\"epub:textref\", element, item, !isBody);\r\n                safeCopyProperty(\"id\", element, item);\r\n                safeCopyProperty(\"epub:type\", element, item);\r\n\r\n                item.children = that.getChildren(element);\r\n\r\n            } else if (item.nodeType === \"par\") {\r\n\r\n                safeCopyProperty(\"id\", element, item);\r\n                safeCopyProperty(\"epub:type\", element, item);\r\n\r\n                item.children = that.getChildren(element);\r\n\r\n            } else if (item.nodeType === \"text\") {\r\n\r\n                safeCopyProperty(\"src\", element, item, true);\r\n                var srcParts = item.src.split('#');\r\n                item.srcFile = srcParts[0];\r\n                item.srcFragmentId = (srcParts.length === 2) ? srcParts[1] : \"\";\r\n                safeCopyProperty(\"id\", element, item);\r\n                // safeCopyProperty(\"epub:textref\", element, item);\r\n\r\n            } else if (item.nodeType === \"audio\") {\r\n                safeCopyProperty(\"src\", element, item, true);\r\n                safeCopyProperty(\"id\", element, item);\r\n                item.clipBegin = SmilDocumentParser.resolveClockValue(element.getAttribute(\"clipBegin\"));\r\n                item.clipEnd = SmilDocumentParser.resolveClockValue(element.getAttribute(\"clipEnd\"));\r\n            }\r\n            else\r\n            {\r\n                return undefined;\r\n            }\r\n\r\n            return item;\r\n        }\r\n\r\n        function makeFakeSmilJson(spineItem) {\r\n            return {\r\n                id: \"\",\r\n                href: \"\",\r\n                spineItemId: spineItem.idref,\r\n                children: [{\r\n                    nodeType: 'seq',\r\n                    textref: spineItem.href,\r\n                    children: [{\r\n                        nodeType: 'par',\r\n                        children: [{\r\n                            nodeType: 'text',\r\n                            src: spineItem.href,\r\n                            srcFile: spineItem.href,\r\n                            srcFragmentId: \"\"\r\n                        }]\r\n                    }]\r\n                }]\r\n            };\r\n        }\r\n\r\n        this.fillSmilData = function(callback) {\r\n            var that = this;\r\n\r\n            if (packageDocument.spineLength() <= 0) {\r\n                callback();\r\n                return;\r\n            }\r\n\r\n            var allFakeSmil = true;\r\n            var mo_map = [];\r\n            var parsingDeferreds = [];\r\n\r\n            for (var spineIdx = 0; spineIdx < packageDocument.spineLength(); spineIdx++) {\r\n                var spineItem = packageDocument.getSpineItem(spineIdx);\r\n\r\n                if (spineItem.media_overlay_id) {\r\n                    var manifestItemSMIL = packageDocument.manifest.getManifestItemByIdref(spineItem.media_overlay_id);\r\n\r\n                    if (!manifestItemSMIL) {\r\n                        console.error(\"Cannot find SMIL manifest item for spine/manifest item?! \" + spineItem.media_overlay_id);\r\n                        continue;\r\n                    }\r\n                    //ASSERT manifestItemSMIL.media_type === \"application/smil+xml\"\r\n\r\n                    var parsingDeferred = $.Deferred();\r\n                    parsingDeferred.media_overlay_id = spineItem.media_overlay_id;\r\n                    parsingDeferreds.push(parsingDeferred);\r\n                    var smilJson = {};\r\n\r\n                    // Push the holder object onto the map early so that order isn't disturbed by asynchronicity:\r\n                    mo_map.push(smilJson);\r\n\r\n                    // The local parsingDeferred variable will have its value replaced on next loop iteration.\r\n                    // Must pass the parsingDeferred through async calls as an argument and it arrives back as myDeferred.\r\n                    that.parse(spineItem, manifestItemSMIL, smilJson, parsingDeferred, function(myDeferred, smilJson) {\r\n                        allFakeSmil = false;\r\n                        myDeferred.resolve();\r\n                    }, function(myDeferred, parseError) {\r\n                        console.log('Error when parsing SMIL manifest item ' + manifestItemSMIL.href + ':');\r\n                        console.log(parseError);\r\n                        myDeferred.resolve();\r\n                    });\r\n                } else {\r\n                    mo_map.push(makeFakeSmilJson(spineItem));\r\n                }\r\n            }\r\n\r\n            $.when.apply($, parsingDeferreds).done(function() {\r\n                packageDocument.getMetadata().setMoMap(mo_map);\r\n                if (allFakeSmil) {\r\n                    console.log(\"No Media Overlays\");\r\n                    packageDocument.getMetadata().setMoMap([]);\r\n                }\r\n                callback();\r\n            });\r\n        }\r\n    };\r\n\r\n    // parse the timestamp and return the value in seconds\r\n    // supports this syntax:\r\n    // http://idpf.org/epub/30/spec/epub30-mediaoverlays.html#app-clock-examples\r\n    SmilDocumentParser.resolveClockValue = function(value) {\r\n        if (!value) return 0;\r\n\r\n        var hours = 0;\r\n        var mins = 0;\r\n        var secs = 0;\r\n\r\n        if (value.indexOf(\"min\") != -1) {\r\n            mins = parseFloat(value.substr(0, value.indexOf(\"min\")));\r\n        } else if (value.indexOf(\"ms\") != -1) {\r\n            var ms = parseFloat(value.substr(0, value.indexOf(\"ms\")));\r\n            secs = ms / 1000;\r\n        } else if (value.indexOf(\"s\") != -1) {\r\n            secs = parseFloat(value.substr(0, value.indexOf(\"s\")));\r\n        } else if (value.indexOf(\"h\") != -1) {\r\n            hours = parseFloat(value.substr(0, value.indexOf(\"h\")));\r\n        } else {\r\n            // parse as hh:mm:ss.fraction\r\n            // this also works for seconds-only, e.g. 12.345\r\n            var arr = value.split(\":\");\r\n            secs = parseFloat(arr.pop());\r\n            if (arr.length > 0) {\r\n                mins = parseFloat(arr.pop());\r\n                if (arr.length > 0) {\r\n                    hours = parseFloat(arr.pop());\r\n                }\r\n            }\r\n        }\r\n        var total = hours * 3600 + mins * 60 + secs;\r\n        return total;\r\n    }\r\n    \r\n    return SmilDocumentParser;\r\n});\r\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\ndefine('epub-model/metadata',['underscore'],\r\n    function (_) {\r\n\r\n        var Metadata = function () {\r\n\r\n            var that = this;\r\n\r\n            var _mediaItemIndexByRefinesId = {};\r\n\r\n            /**\r\n             * Iterate over media items and apply callback (synchronously) on each one of them.\r\n             * @param iteratorCallback the iterator callback function, will be called once for each media item,\r\n             * and the item will be passed as the (one and only) argument.\r\n             * @returns the Metadata object for chaining.\r\n             */\r\n            this.eachMediaItem = function(iteratorCallback) {\r\n                if (that.mediaItems) {\r\n                    _.each(that.mediaItems, iteratorCallback);\r\n                }\r\n                return this;\r\n            };\r\n\r\n            this.getMediaItemByRefinesId = function(id) {\r\n                return _mediaItemIndexByRefinesId[id];\r\n            };\r\n\r\n            this.setMoMap = function(mediaOverlaysMap) {\r\n                that.media_overlay.smil_models = mediaOverlaysMap;\r\n            };\r\n\r\n            // Initialize indexes\r\n            this.eachMediaItem(function(item) {\r\n                var id = item.refines;\r\n                var hash = id.indexOf('#');\r\n                if (hash >= 0) {\r\n                    var start = hash+1;\r\n                    var end = id.length-1;\r\n                    id = id.substr(start, end);\r\n                }\r\n                id = id.trim();\r\n\r\n                _mediaItemIndexByRefinesId[id] = item;\r\n            });\r\n\r\n\r\n        };\r\n        return Metadata;\r\n    });\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\ndefine('epub-model/manifest',['underscore'],\r\n    function (_) {\r\n\r\n        var Manifest = function (manifestJson) {\r\n\r\n            var _manifestIndexById = {};\r\n            var _navItem;\r\n\r\n            this.manifestLength = function() {\r\n                return manifestJson.length;\r\n            };\r\n\r\n            this.getManifestItemByIdref = function (idref) {\r\n                return _manifestIndexById[idref];\r\n            };\r\n\r\n            /**\r\n             * Iterate over manifest items and apply callback (synchronously) on each one of them.\r\n             * @param iteratorCallback the iterator callback function, will be called once for each manifest item,\r\n             * and the item will be passed as the (one and only) argument.\r\n             * @returns the Manifest object for chaining.\r\n             */\r\n            this.each = function(iteratorCallback) {\r\n                _.each(manifestJson, iteratorCallback);\r\n                return this;\r\n            };\r\n\r\n            this.getNavItem = function () {\r\n                return _navItem;\r\n            };\r\n\r\n            // Initialize indexes\r\n            this.each(function(manifestItem) {\r\n                _manifestIndexById[manifestItem.id] = manifestItem;\r\n\r\n                if (manifestItem.properties && manifestItem.properties.indexOf(\"nav\") !== -1) {\r\n                    _navItem = manifestItem;\r\n                }\r\n            });\r\n\r\n        };\r\n        return Manifest;\r\n    });\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\ndefine('epub-model/package_document_parser',['jquery', 'underscore', 'epub-fetch/markup_parser', 'URIjs', './package_document',\r\n        './smil_document_parser', './metadata', './manifest'],\r\n    function($, _, MarkupParser, URI, PackageDocument, SmilDocumentParser, Metadata,\r\n             Manifest) {\r\n\r\n        // `PackageDocumentParser` is used to parse the xml of an epub package\r\n    // document and build a javascript object. The constructor accepts an\r\n    // instance of `URI` that is used to resolve paths during the process\r\n    var PackageDocumentParser = function(bookRoot, publicationFetcher) {\r\n\r\n        var _packageFetcher = publicationFetcher;\r\n        var _deferredXmlDom = $.Deferred();\r\n        var _xmlDom;\r\n\r\n        function onError(error) {\r\n            if (error) {\r\n                if (error.message) {\r\n                    console.error(error.message);\r\n                }\r\n                if (error.stack) {\r\n                    console.error(error.stack);\r\n                }\r\n            }\r\n        }\r\n\r\n        publicationFetcher.getPackageDom(function(packageDom){\r\n            _xmlDom = packageDom;\r\n            _deferredXmlDom.resolve(packageDom);\r\n        }, onError);\r\n\r\n        function fillSmilData(packageDocument, callback) {\r\n\r\n            var smilParser = new SmilDocumentParser(packageDocument, publicationFetcher);\r\n\r\n            smilParser.fillSmilData(function() {\r\n\r\n                // return the parse result\r\n                callback(packageDocument);\r\n            });\r\n\r\n        }\r\n\r\n        // Parse an XML package document into a javascript object\r\n        this.parse = function(callback) {\r\n\r\n            _deferredXmlDom.done(function (xmlDom) {\r\n                var metadata = getMetadata(xmlDom);\r\n\r\n                var spineElem = xmlDom.getElementsByTagNameNS(\"*\", \"spine\")[0];\r\n                var page_prog_dir = getElemAttr(xmlDom, 'spine', \"page-progression-direction\");\r\n\r\n                // TODO: Bindings are unused\r\n                var bindings = getJsonBindings(xmlDom);\r\n\r\n                var manifest = new Manifest(getJsonManifest(xmlDom));\r\n                var spine = getJsonSpine(xmlDom, manifest, metadata);\r\n\r\n                // try to find a cover image\r\n                var cover = getCoverHref(xmlDom);\r\n                if (cover) {\r\n                    metadata.cover_href = cover;\r\n                }\r\n\r\n                $.when(updateMetadataWithIBookProperties(metadata)).then(function() {\r\n\r\n                    _packageFetcher.setPackageMetadata(metadata, function () {\r\n                        var packageDocument = new PackageDocument(publicationFetcher.getPackageUrl(),\r\n                            publicationFetcher, metadata, spine, manifest);\r\n\r\n                        packageDocument.setPageProgressionDirection(page_prog_dir);\r\n                        fillSmilData(packageDocument, callback);\r\n                    });\r\n                });\r\n\r\n            });\r\n        };\r\n\r\n        function updateMetadataWithIBookProperties(metadata) {\r\n\r\n            var dff = $.Deferred();\r\n\r\n            //if layout not set\r\n            if(!metadata.rendition_layout)\r\n            {\r\n                var pathToIBooksSpecificXml = \"/META-INF/com.apple.ibooks.display-options.xml\";\r\n\r\n                publicationFetcher.relativeToPackageFetchFileContents(pathToIBooksSpecificXml, 'text', function (ibookPropText) {\r\n                    if(ibookPropText) {\r\n                        var parser = new MarkupParser();\r\n                        var propModel = parser.parseXml(ibookPropText);\r\n                        var fixLayoutProp = $(\"option[name=fixed-layout]\", propModel)[0];\r\n                        if(fixLayoutProp) {\r\n                            var fixLayoutVal = $(fixLayoutProp).text();\r\n                            if(fixLayoutVal === \"true\") {\r\n                                metadata.rendition_layout = \"pre-paginated\";\r\n                                console.log(\"using com.apple.ibooks.display-options.xml fixed-layout property\");\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    dff.resolve();\r\n\r\n                }, function (err) {\r\n\r\n                    console.log(\"com.apple.ibooks.display-options.xml not found\");\r\n                    dff.resolve();\r\n                });\r\n            }\r\n            else {\r\n                dff.resolve();\r\n            }\r\n\r\n            return dff.promise();\r\n        }\r\n\r\n\r\n        function getJsonSpine(xmlDom, manifest, metadata) {\r\n\r\n            var $spineElements;\r\n            var jsonSpine = [];\r\n\r\n            $spineElements = $(findXmlElemByLocalNameAnyNS(xmlDom,\"spine\")).children();\r\n            $.each($spineElements, function (spineElementIndex, currSpineElement) {\r\n\r\n                var $currSpineElement = $(currSpineElement);\r\n                var idref = $currSpineElement.attr(\"idref\") ? $currSpineElement.attr(\"idref\") : \"\";\r\n                var manifestItem = manifest.getManifestItemByIdref(idref);\r\n\r\n                var id = $currSpineElement.attr(\"id\");\r\n                var viewport = undefined;\r\n                _.each(metadata.rendition_viewports, function(vp) {\r\n                    if (vp.refines == id) {\r\n                        viewport = vp.viewport;\r\n                        return true; // break\r\n                    }\r\n                });\r\n\r\n                var spineItem = {\r\n                    rendition_viewport: viewport,\r\n                    idref: idref,\r\n                    href: manifestItem.href,\r\n                    manifest_id: manifestItem.id,\r\n                    media_type: manifestItem.media_type,\r\n                    media_overlay_id: manifestItem.media_overlay_id,\r\n                    linear: $currSpineElement.attr(\"linear\") ? $currSpineElement.attr(\"linear\") : \"\",\r\n                    properties: $currSpineElement.attr(\"properties\") ? $currSpineElement.attr(\"properties\") : \"\"\r\n                };\r\n\r\n                var parsedProperties = parsePropertiesString(spineItem.properties);\r\n                _.extend(spineItem, parsedProperties);\r\n\r\n                jsonSpine.push(spineItem);\r\n            });\r\n\r\n            return jsonSpine;\r\n        }\r\n\r\n        function findXmlElemByLocalNameAnyNS(rootElement, localName, predicate) {\r\n            var elements = rootElement.getElementsByTagNameNS(\"*\", localName);\r\n            if (predicate) {\r\n                return _.find(elements, predicate);\r\n            } else {\r\n                return elements[0];\r\n            }\r\n        }\r\n\r\n        function filterXmlElemsByLocalNameAnyNS(rootElement, localName, predicate) {\r\n            var elements = rootElement.getElementsByTagNameNS(\"*\", localName);\r\n            return _.filter(elements, predicate);\r\n        }\r\n\r\n        function getElemText(rootElement, localName, predicate) {\r\n            var foundElement = findXmlElemByLocalNameAnyNS(rootElement, localName, predicate);\r\n            if (foundElement) {\r\n                return foundElement.textContent;\r\n            } else {\r\n                return '';\r\n            }\r\n        }\r\n\r\n        function getElemAttr(rootElement, localName, attrName, predicate) {\r\n            var foundElement = findXmlElemByLocalNameAnyNS(rootElement, localName, predicate);\r\n            if (foundElement) {\r\n                return foundElement.getAttribute(attrName);\r\n            } else {\r\n                return '';\r\n            }\r\n        }\r\n\r\n        function getMetaElemPropertyText(rootElement, attrPropertyValue) {\r\n\r\n            var foundElement = findXmlElemByLocalNameAnyNS(rootElement, \"meta\", function (element) {\r\n                return element.getAttribute(\"property\") === attrPropertyValue;\r\n            });\r\n\r\n            if (foundElement) {\r\n                return foundElement.textContent;\r\n            } else {\r\n                return '';\r\n            }\r\n        }\r\n\r\n\r\n        function getMetadata(xmlDom) {\r\n\r\n            var metadata = new Metadata();\r\n            var metadataElem = findXmlElemByLocalNameAnyNS(xmlDom, \"metadata\");\r\n            var packageElem = findXmlElemByLocalNameAnyNS(xmlDom, \"package\");\r\n            var spineElem = findXmlElemByLocalNameAnyNS(xmlDom, \"spine\");\r\n\r\n\r\n            metadata.author = getElemText(metadataElem, \"creator\");\r\n            metadata.description = getElemText(metadataElem, \"description\");\r\n            metadata.epub_version =\r\n                packageElem.getAttribute(\"version\") ? packageElem.getAttribute(\"version\") : \"\";\r\n            metadata.id = getElemText(metadataElem,\"identifier\");\r\n            metadata.language = getElemText(metadataElem, \"language\");\r\n            metadata.modified_date = getMetaElemPropertyText(metadataElem, \"dcterms:modified\");\r\n            metadata.ncx = spineElem.getAttribute(\"toc\") ? spineElem.getAttribute(\"toc\") : \"\";\r\n            metadata.pubdate = getElemText(metadataElem, \"date\");\r\n            metadata.publisher = getElemText(metadataElem, \"publisher\");\r\n            metadata.rights = getElemText(metadataElem, \"rights\");\r\n            metadata.title = getElemText(metadataElem, \"title\");\r\n\r\n            metadata.rendition_orientation = getMetaElemPropertyText(metadataElem, \"rendition:orientation\");\r\n            metadata.rendition_layout = getMetaElemPropertyText(metadataElem, \"rendition:layout\");\r\n            metadata.rendition_spread = getMetaElemPropertyText(metadataElem, \"rendition:spread\");\r\n            metadata.rendition_flow = getMetaElemPropertyText(metadataElem, \"rendition:flow\");\r\n\r\n\r\n\r\n\r\n\r\n\r\n            //http://www.idpf.org/epub/301/spec/epub-publications.html#fxl-property-viewport\r\n            \r\n            //metadata.rendition_viewport = getMetaElemPropertyText(metadataElem, \"rendition:viewport\");\r\n            metadata.rendition_viewport = getElemText(metadataElem, \"meta\", function (element) {\r\n                return element.getAttribute(\"property\") === \"rendition:viewport\" && !element.hasAttribute(\"refines\")\r\n            });\r\n\r\n            var viewports = [];\r\n            var viewportMetaElems = filterXmlElemsByLocalNameAnyNS(metadataElem, \"meta\", function (element) {\r\n                return element.getAttribute(\"property\") === \"rendition:viewport\" && element.hasAttribute(\"refines\");\r\n            });\r\n            _.each(viewportMetaElems, function(currItem) {\r\n                var id = currItem.getAttribute(\"refines\");\r\n                if (id) {\r\n                    var hash = id.indexOf('#');\r\n                    if (hash >= 0) {\r\n                        var start = hash+1;\r\n                        var end = id.length-1;\r\n                        id = id.substr(start, end);\r\n                    }\r\n                    id = id.trim();\r\n                }\r\n                \r\n                var vp = {\r\n                  refines: id,\r\n                  viewport: currItem.textContent\r\n                };\r\n                viewports.push(vp);\r\n            });\r\n            \r\n            metadata.rendition_viewports = viewports;\r\n\r\n            \r\n            \r\n            \r\n            \r\n            \r\n            // Media part\r\n            metadata.mediaItems = [];\r\n\r\n            var overlayElems = filterXmlElemsByLocalNameAnyNS(metadataElem, \"meta\", function (element) {\r\n                return element.getAttribute(\"property\") === \"media:duration\" && element.hasAttribute(\"refines\");\r\n            });\r\n\r\n            _.each(overlayElems, function(currItem) {\r\n                metadata.mediaItems.push({\r\n                  refines: currItem.getAttribute(\"refines\"),\r\n                  duration: SmilDocumentParser.resolveClockValue(currItem.textContent)\r\n               });\r\n            });\r\n\r\n            metadata.media_overlay = {\r\n                duration: SmilDocumentParser.resolveClockValue(\r\n                    getElemText(metadataElem, \"meta\", function (element) {\r\n                        return element.getAttribute(\"property\") === \"media:duration\" && !element.hasAttribute(\"refines\")\r\n                    })\r\n                ),\r\n                narrator: getMetaElemPropertyText(metadataElem, \"media:narrator\"),\r\n                activeClass: getMetaElemPropertyText(metadataElem, \"media:active-class\"),\r\n                playbackActiveClass: getMetaElemPropertyText(metadataElem, \"media:playback-active-class\"),\r\n                smil_models: [],\r\n                skippables: [\"sidebar\", \"practice\", \"marginalia\", \"annotation\", \"help\", \"note\", \"footnote\", \"rearnote\",\r\n                    \"table\", \"table-row\", \"table-cell\", \"list\", \"list-item\", \"pagebreak\"],\r\n                escapables: [\"sidebar\", \"bibliography\", \"toc\", \"loi\", \"appendix\", \"landmarks\", \"lot\", \"index\",\r\n                    \"colophon\", \"epigraph\", \"conclusion\", \"afterword\", \"warning\", \"epilogue\", \"foreword\",\r\n                    \"introduction\", \"prologue\", \"preface\", \"preamble\", \"notice\", \"errata\", \"copyright-page\",\r\n                    \"acknowledgments\", \"other-credits\", \"titlepage\", \"imprimatur\", \"contributors\", \"halftitlepage\",\r\n                    \"dedication\", \"help\", \"annotation\", \"marginalia\", \"practice\", \"note\", \"footnote\", \"rearnote\",\r\n                    \"footnotes\", \"rearnotes\", \"bridgehead\", \"page-list\", \"table\", \"table-row\", \"table-cell\", \"list\",\r\n                    \"list-item\", \"glossary\"]\r\n            };\r\n\r\n            return metadata;\r\n        }\r\n\r\n        function getJsonManifest(xmlDom) {\r\n\r\n            var $manifestItems = $(findXmlElemByLocalNameAnyNS(xmlDom, \"manifest\")).children();\r\n            var jsonManifest = [];\r\n\r\n            $.each($manifestItems, function (manifestElementIndex, currManifestElement) {\r\n\r\n                var $currManifestElement = $(currManifestElement);\r\n                var currManifestElementHref = $currManifestElement.attr(\"href\") ? $currManifestElement.attr(\"href\") :\r\n                    \"\";\r\n                var manifestItem = {\r\n\r\n                    href: currManifestElementHref,\r\n                    id: $currManifestElement.attr(\"id\") ? $currManifestElement.attr(\"id\") : \"\",\r\n                    media_overlay_id: $currManifestElement.attr(\"media-overlay\") ?\r\n                        $currManifestElement.attr(\"media-overlay\") : \"\",\r\n                    media_type: $currManifestElement.attr(\"media-type\") ? $currManifestElement.attr(\"media-type\") : \"\",\r\n                    properties: $currManifestElement.attr(\"properties\") ? $currManifestElement.attr(\"properties\") : \"\"\r\n                };\r\n                // console.log('pushing manifest item to JSON manifest. currManifestElementHref: [' + currManifestElementHref + \r\n                //     '], manifestItem.href: [' + manifestItem.href +\r\n                //     '], manifestItem:');\r\n                // console.log(manifestItem);\r\n                jsonManifest.push(manifestItem);\r\n            });\r\n\r\n            return jsonManifest;\r\n        }\r\n\r\n        function getJsonBindings(xmlDom) {\r\n\r\n            var $bindings = $(findXmlElemByLocalNameAnyNS(xmlDom, \"bindings\")).children();\r\n            var jsonBindings = [];\r\n\r\n            $.each($bindings, function (bindingElementIndex, currBindingElement) {\r\n\r\n                var $currBindingElement = $(currBindingElement);\r\n                var binding = {\r\n\r\n                    handler: $currBindingElement.attr(\"handler\") ? $currBindingElement.attr(\"handler\") : \"\",\r\n                    media_type: $currBindingElement.attr(\"media-type\") ? $currBindingElement.attr(\"media-type\") : \"\"\r\n                };\r\n\r\n                jsonBindings.push(binding);\r\n            });\r\n\r\n            return jsonBindings;\r\n        }\r\n\r\n        function getCoverHref(xmlDom) {\r\n\r\n            var manifest;\r\n            var $imageNode;\r\n            manifest = findXmlElemByLocalNameAnyNS(xmlDom, \"manifest\");\r\n\r\n            // epub3 spec for a cover image is like this:\r\n            /*<item properties=\"cover-image\" id=\"ci\" href=\"cover.svg\" media-type=\"image/svg+xml\" />*/\r\n            $imageNode = $(findXmlElemByLocalNameAnyNS(manifest, \"item\", function (element) {\r\n                var attr = element.getAttribute(\"properties\");\r\n                return attr && _.contains(attr.split(\" \"), \"cover-image\");\r\n            }));\r\n            if ($imageNode.length === 1 && $imageNode.attr(\"href\")) {\r\n                return $imageNode.attr(\"href\");\r\n            }\r\n\r\n            // some epub2's cover image is like this:\r\n            /*<meta name=\"cover\" content=\"cover-image-item-id\" />*/\r\n            var metaNode = $(findXmlElemByLocalNameAnyNS(xmlDom, \"meta\", function (element) {\r\n                return element.getAttribute(\"name\") === \"cover\";\r\n            }));\r\n            var contentAttr = metaNode.attr(\"content\");\r\n            if (metaNode.length === 1 && contentAttr) {\r\n                $imageNode = $(findXmlElemByLocalNameAnyNS(manifest, \"item\", function (element) {\r\n                    return element.getAttribute(\"id\") === contentAttr;\r\n                }));\r\n                if ($imageNode.length === 1 && $imageNode.attr(\"href\")) {\r\n                    return $imageNode.attr(\"href\");\r\n                }\r\n            }\r\n\r\n            // that didn't seem to work so, it think epub2 just uses item with id=cover\r\n            $imageNode = $(findXmlElemByLocalNameAnyNS(manifest, \"item\", function (element) {\r\n                return element.getAttribute(\"id\") === \"cover\";\r\n            }));\r\n            if ($imageNode.length === 1 && $imageNode.attr(\"href\")) {\r\n                return $imageNode.attr(\"href\");\r\n            }\r\n\r\n            // seems like there isn't one, thats ok...\r\n            return null;\r\n        }\r\n\r\n        function parsePropertiesString(str) {\r\n            var properties = {};\r\n            var allPropStrs = str.split(\" \"); // split it on white space\r\n            for (var i = 0; i < allPropStrs.length; i++) {\r\n\r\n                //ReadiumSDK.Models.SpineItem.RENDITION_ORIENTATION_LANDSCAPE\r\n                if (allPropStrs[i] === \"rendition:orientation-landscape\") properties.rendition_orientation = \"landscape\";\r\n\r\n                //ReadiumSDK.Models.SpineItem.RENDITION_ORIENTATION_PORTRAIT\r\n                if (allPropStrs[i] === \"rendition:orientation-portrait\") properties.rendition_orientation = \"portrait\";\r\n\r\n                //ReadiumSDK.Models.SpineItem.RENDITION_ORIENTATION_AUTO\r\n                if (allPropStrs[i] === \"rendition:orientation-auto\") properties.rendition_orientation = \"auto\";\r\n\r\n\r\n                //ReadiumSDK.Models.SpineItem.RENDITION_SPREAD_NONE\r\n                if (allPropStrs[i] === \"rendition:spread-none\") properties.rendition_spread = \"none\";\r\n\r\n                //ReadiumSDK.Models.SpineItem.RENDITION_SPREAD_LANDSCAPE\r\n                if (allPropStrs[i] === \"rendition:spread-landscape\") properties.rendition_spread = \"landscape\";\r\n\r\n                //ReadiumSDK.Models.SpineItem.RENDITION_SPREAD_PORTRAIT\r\n                if (allPropStrs[i] === \"rendition:spread-portrait\") properties.rendition_spread = \"portrait\";\r\n\r\n                //ReadiumSDK.Models.SpineItem.RENDITION_SPREAD_BOTH\r\n                if (allPropStrs[i] === \"rendition:spread-both\") properties.rendition_spread = \"both\";\r\n\r\n                //ReadiumSDK.Models.SpineItem.RENDITION_SPREAD_AUTO\r\n                if (allPropStrs[i] === \"rendition:spread-auto\") properties.rendition_spread = \"auto\";\r\n\r\n\r\n                //ReadiumSDK.Models.SpineItem.RENDITION_FLOW_PAGINATED\r\n                if (allPropStrs[i] === \"rendition:flow-paginated\") properties.rendition_flow = \"paginated\";\r\n\r\n                //ReadiumSDK.Models.SpineItem.RENDITION_FLOW_SCROLLED_CONTINUOUS\r\n                if (allPropStrs[i] === \"rendition:flow-scrolled-continuous\") properties.rendition_flow = \"scrolled-continuous\";\r\n\r\n                //ReadiumSDK.Models.SpineItem.RENDITION_FLOW_SCROLLED_DOC\r\n                if (allPropStrs[i] === \"rendition:flow-scrolled-doc\") properties.rendition_flow = \"scrolled-doc\";\r\n\r\n                //ReadiumSDK.Models.SpineItem.RENDITION_FLOW_AUTO\r\n                if (allPropStrs[i] === \"rendition:flow-auto\") properties.rendition_flow = \"auto\";\r\n\r\n\r\n\r\n                //ReadiumSDK.Models.SpineItem.SPREAD_CENTER\r\n                if (allPropStrs[i] === \"rendition:page-spread-center\") properties.page_spread = \"page-spread-center\";\r\n\r\n                //ReadiumSDK.Models.SpineItem.SPREAD_LEFT\r\n                if (allPropStrs[i] === \"page-spread-left\") properties.page_spread = \"page-spread-left\";\r\n\r\n                //ReadiumSDK.Models.SpineItem.SPREAD_RIGHT\r\n                if (allPropStrs[i] === \"page-spread-right\") properties.page_spread = \"page-spread-right\";\r\n\r\n                //ReadiumSDK.Models.SpineItem.RENDITION_LAYOUT_REFLOWABLE\r\n                if (allPropStrs[i] === \"rendition:layout-reflowable\") {\r\n                    properties.fixed_flow = false; // TODO: only used in spec tests!\r\n                    properties.rendition_layout = \"reflowable\";\r\n                }\r\n\r\n                //ReadiumSDK.Models.SpineItem.RENDITION_LAYOUT_PREPAGINATED\r\n                if (allPropStrs[i] === \"rendition:layout-pre-paginated\") {\r\n                    properties.fixed_flow = true; // TODO: only used in spec tests!\r\n                    properties.rendition_layout = \"pre-paginated\";\r\n                }\r\n            }\r\n            return properties;\r\n        }\r\n\r\n    };\r\n\r\n    return PackageDocumentParser;\r\n});\r\n\ndefine('epub-model', ['epub-model/package_document_parser'], function (main) { return main; });\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\ndefine('epub-fetch/iframe_zip_loader',['URIjs', 'views/iframe_loader', 'underscore'], function(URI, IFrameLoader, _){\r\n\r\n    var zipIframeLoader = function( getCurrentResourceFetcher, contentDocumentTextPreprocessor) {\r\n\r\n        var basicIframeLoader = new IFrameLoader();\r\n\r\n        var self = this;\r\n        \r\n        var _contentDocumentTextPreprocessor = contentDocumentTextPreprocessor;\r\n\r\n        this.addIFrameEventListener = function (eventName, callback, context) {\r\n            basicIframeLoader.addIFrameEventListener(eventName, callback, context);\r\n        };\r\n\r\n        this.updateIframeEvents = function (iframe) {\r\n            basicIframeLoader.updateIframeEvents(iframe);\r\n        };\r\n        \r\n        this.loadIframe = function(iframe, src, callback, caller, attachedData) {\r\n\r\n            var loadedDocumentUri = new URI(src).absoluteTo(iframe.baseURI).search('').hash('').toString();\r\n\r\n            var shouldConstructDomProgrammatically = getCurrentResourceFetcher().shouldConstructDomProgrammatically();\r\n            if (shouldConstructDomProgrammatically) {\r\n\r\n                    getCurrentResourceFetcher().fetchContentDocument(attachedData, loadedDocumentUri,\r\n                        function (resolvedContentDocumentDom) {\r\n                            self._loadIframeWithDocument(iframe,\r\n                                attachedData,\r\n                                resolvedContentDocumentDom.documentElement.outerHTML,\r\n                                function () {\r\n                                    callback.call(caller, true, attachedData);\r\n                                });\r\n                        }, function (err) {\r\n                            callback.call(caller, false, attachedData);\r\n                        }\r\n                    );\r\n            } else {\r\n                fetchContentDocument(loadedDocumentUri, function (contentDocumentHtml) {\r\n                      if (!contentDocumentHtml) {\r\n                          //failed to load content document\r\n                          callback.call(caller, false, attachedData);\r\n                      } else {\r\n                          self._loadIframeWithDocument(iframe, attachedData, contentDocumentHtml, function () {\r\n                              callback.call(caller, true, attachedData);\r\n                          });\r\n                      }\r\n                });\r\n            }\r\n        };\r\n\r\n        this._loadIframeWithDocument = function (iframe, attachedData, contentDocumentData, callback) {\r\n\r\n            var isIE = (window.navigator.userAgent.indexOf(\"Trident\") > 0);\r\n            if (!isIE) {\r\n                var contentType = 'text/html';\r\n                if (attachedData.spineItem.media_type && attachedData.spineItem.media_type.length) {\r\n                    contentType = attachedData.spineItem.media_type;\r\n                }\r\n\r\n                var documentDataUri = window.URL.createObjectURL(\r\n                    new Blob([contentDocumentData], {'type': contentType})\r\n                );\r\n            } else {\r\n                // Internet Explorer doesn't handle loading documents from Blobs correctly.\r\n                // TODO: Currently using the document.write() approach only for IE, as it breaks CSS selectors\r\n                // with namespaces for some reason (e.g. the childrens-media-query sample EPUB)\r\n                iframe.contentWindow.document.open();\r\n                \r\n                // Currently not handled automatically by winstore-jscompat,\r\n                // so we're doing it manually. See:\r\n                // https://github.com/MSOpenTech/winstore-jscompat/\r\n                if (window.MSApp && window.MSApp.execUnsafeLocalFunction) {\r\n                    window.MSApp.execUnsafeLocalFunction(function() {\r\n                        iframe.contentWindow.document.write(contentDocumentData);\r\n                    });\r\n                } else {\r\n                    iframe.contentWindow.document.write(contentDocumentData);\r\n                }\r\n            }\r\n\r\n            iframe.onload = function () {\r\n\r\n                self.updateIframeEvents(iframe);\r\n\r\n                var mathJax = iframe.contentWindow.MathJax;\r\n                if (mathJax) {\r\n                    // If MathJax is being used, delay the callback until it has completed rendering\r\n                    var mathJaxCallback = _.once(callback);\r\n                    mathJax.Hub.Queue(mathJaxCallback);\r\n                    // Or at an 8 second timeout, which ever comes first\r\n                    // window.setTimeout(mathJaxCallback, 8000);\r\n                } else {\r\n                    callback();\r\n                }\r\n\r\n                if (!isIE) {\r\n                    window.URL.revokeObjectURL(documentDataUri);\r\n                }\r\n            };\r\n\r\n            if (!isIE) {\r\n                iframe.setAttribute(\"src\", documentDataUri);\r\n            } else {\r\n                iframe.contentWindow.document.close();\r\n            }\r\n        };\r\n\r\n        function fetchHtmlAsText(path, callback) {\r\n\r\n            $.ajax({\r\n                url: path,\r\n                dataType: 'html',\r\n                async: true,\r\n                success: function (result) {\r\n\r\n                    callback(result);\r\n                },\r\n                error: function (xhr, status, errorThrown) {\r\n                    console.error('Error when AJAX fetching ' + path);\r\n                    console.error(status);\r\n                    console.error(errorThrown);\r\n                    callback();\r\n                }\r\n            });\r\n        }\r\n\r\n        function fetchContentDocument(src, callback) {\r\n\r\n            fetchHtmlAsText(src, function (contentDocumentHtml) {\r\n\r\n                if (!contentDocumentHtml) {\r\n                    callback();\r\n                    return;\r\n                }\r\n\r\n                if (_contentDocumentTextPreprocessor) {\r\n                    contentDocumentHtml = _contentDocumentTextPreprocessor(src, contentDocumentHtml);\r\n                }\r\n\r\n                callback(contentDocumentHtml);\r\n            });\r\n        }\r\n    };\r\n\r\n    return zipIframeLoader;\r\n});\r\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\n\r\ndefine('Readium',['text!version.json', 'jquery', 'underscore', 'views/reader_view', 'epub-fetch',\r\n        'epub-model/package_document_parser', 'epub-fetch/iframe_zip_loader', 'views/iframe_loader',\r\n        ],\r\n    function (versionText, $, _, ReaderView, PublicationFetcher,\r\n              PackageParser, IframeZipLoader, IframeLoader) {\r\n\r\n    var Readium = function(readiumOptions, readerOptions){\r\n\r\n        var _options = { mathJaxUrl: readerOptions.mathJaxUrl };\r\n\r\n        var _contentDocumentTextPreprocessor = function(src, contentDocumentHtml) {\r\n\r\n            function injectedScript() {\r\n\r\n                navigator.epubReadingSystem = window.parent.navigator.epubReadingSystem;\r\n                window.parent = window.self;\r\n                window.top = window.self;\r\n            }\r\n\r\n            var sourceParts = src.split(\"/\");\r\n            sourceParts.pop(); //remove source file name\r\n\r\n            var base = \"<base href=\\\"\" + sourceParts.join(\"/\") + \"/\" + \"\\\"/>\";\r\n\r\n            var scripts = \"<script type=\\\"text/javascript\\\">(\" + injectedScript.toString() + \")()<\\/script>\";\r\n            \r\n            if (_options && _options.mathJaxUrl && contentDocumentHtml.indexOf(\"<math\") >= 0) {\r\n                scripts += \"<script type=\\\"text/javascript\\\" src=\\\"\" + _options.mathJaxUrl + \"\\\"><\\/script>\";\r\n            }\r\n\r\n            return contentDocumentHtml.replace(/(<head.*?>)/, \"$1\" + base + scripts);\r\n        };\r\n        \r\n        var self = this;\r\n\r\n        var _currentPublicationFetcher;\r\n\r\n        var jsLibRoot = readiumOptions.jsLibRoot;\r\n\r\n        if (!readiumOptions.useSimpleLoader){\r\n            readerOptions.iframeLoader = new IframeZipLoader(function() { return _currentPublicationFetcher; }, _contentDocumentTextPreprocessor);\r\n        }\r\n        else{\r\n            readerOptions.iframeLoader = new IframeLoader();\r\n        }\r\n        \r\n\r\n        this.reader = new ReaderView(readerOptions);\r\n        ReadiumSDK.reader = this.reader;\r\n\r\n        this.openPackageDocument = function(bookRoot, callback, openPageRequest)  {\r\n            if (_currentPublicationFetcher) {\r\n                _currentPublicationFetcher.flushCache();\r\n            }\r\n\r\n            var cacheSizeEvictThreshold = null;\r\n            if (readiumOptions.cacheSizeEvictThreshold) {\r\n                cacheSizeEvictThreshold = readiumOptions.cacheSizeEvictThreshold;\r\n            }\r\n\r\n            _currentPublicationFetcher = new PublicationFetcher(bookRoot, jsLibRoot, window, cacheSizeEvictThreshold, _contentDocumentTextPreprocessor);\r\n\r\n            _currentPublicationFetcher.initialize(function() {\r\n\r\n                var _packageParser = new PackageParser(bookRoot, _currentPublicationFetcher);\r\n\r\n                _packageParser.parse(function(packageDocument){\r\n                    var openBookOptions = readiumOptions.openBookOptions || {};\r\n                    var openBookData = $.extend(packageDocument.getSharedJsPackageData(), openBookOptions);\r\n\r\n                    if (openPageRequest) {\r\n                        openBookData.openPageRequest = openPageRequest;\r\n                    }\r\n                    self.reader.openBook(openBookData);\r\n\r\n                    var options = {\r\n                        packageDocumentUrl : _currentPublicationFetcher.getPackageUrl(),\r\n                        metadata: packageDocument.getMetadata()\r\n                    };\r\n\r\n                    if (callback){\r\n                        // gives caller access to document metadata like the table of contents\r\n                        callback(packageDocument, options);\r\n                    }\r\n                });\r\n            });\r\n        };\r\n\r\n        this.closePackageDocument = function() {\r\n            if (_currentPublicationFetcher) {\r\n                _currentPublicationFetcher.flushCache();\r\n            }\r\n        };\r\n\r\n        ReadiumSDK.emit(ReadiumSDK.Events.READER_INITIALIZED, ReadiumSDK.reader);\r\n    };\r\n    \r\n    Readium.version = JSON.parse(versionText);\r\n\r\n    return Readium;\r\n\r\n});\r\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\ndefine('readium-js',['Readium'], function (Readium) {\r\n//noop\r\n});\r\n\n"
  ]
}